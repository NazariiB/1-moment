"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-sketch-canvas";
exports.ids = ["vendor-chunks/react-sketch-canvas"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-sketch-canvas/dist/react-sketch-canvas.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/react-sketch-canvas/dist/react-sketch-canvas.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactSketchCanvas: () => (/* binding */ ReactSketchCanvas)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar runtime = {exports: {}};\n\n/**\n * Copyright (c) 2014-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n(function (module) {\nvar runtime = (function (exports) {\n\n  var Op = Object.prototype;\n  var hasOwn = Op.hasOwnProperty;\n  var undefined$1; // More compressible than void 0.\n  var $Symbol = typeof Symbol === \"function\" ? Symbol : {};\n  var iteratorSymbol = $Symbol.iterator || \"@@iterator\";\n  var asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\";\n  var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n\n  function define(obj, key, value) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n    return obj[key];\n  }\n  try {\n    // IE 8 has a broken Object.defineProperty that only works on DOM objects.\n    define({}, \"\");\n  } catch (err) {\n    define = function(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;\n    var generator = Object.create(protoGenerator.prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  exports.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  // This is a polyfill for %IteratorPrototype% for environments that\n  // don't natively support it.\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n\n  var getProto = Object.getPrototypeOf;\n  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  if (NativeIteratorPrototype &&\n      NativeIteratorPrototype !== Op &&\n      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {\n    // This environment has a native %IteratorPrototype%; use it instead\n    // of the polyfill.\n    IteratorPrototype = NativeIteratorPrototype;\n  }\n\n  var Gp = GeneratorFunctionPrototype.prototype =\n    Generator.prototype = Object.create(IteratorPrototype);\n  GeneratorFunction.prototype = GeneratorFunctionPrototype;\n  define(Gp, \"constructor\", GeneratorFunctionPrototype);\n  define(GeneratorFunctionPrototype, \"constructor\", GeneratorFunction);\n  GeneratorFunction.displayName = define(\n    GeneratorFunctionPrototype,\n    toStringTagSymbol,\n    \"GeneratorFunction\"\n  );\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      define(prototype, method, function(arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n\n  exports.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  exports.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n      define(genFun, toStringTagSymbol, \"GeneratorFunction\");\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `hasOwn.call(value, \"__await\")` to determine if the yielded value is\n  // meant to be awaited.\n  exports.awrap = function(arg) {\n    return { __await: arg };\n  };\n\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (record.type === \"throw\") {\n        reject(record.arg);\n      } else {\n        var result = record.arg;\n        var value = result.value;\n        if (value &&\n            typeof value === \"object\" &&\n            hasOwn.call(value, \"__await\")) {\n          return PromiseImpl.resolve(value.__await).then(function(value) {\n            invoke(\"next\", value, resolve, reject);\n          }, function(err) {\n            invoke(\"throw\", err, resolve, reject);\n          });\n        }\n\n        return PromiseImpl.resolve(value).then(function(unwrapped) {\n          // When a yielded Promise is resolved, its final value becomes\n          // the .value of the Promise<{value,done}> result for the\n          // current iteration.\n          result.value = unwrapped;\n          resolve(result);\n        }, function(error) {\n          // If a rejected Promise was yielded, throw the rejection back\n          // into the async generator function so it can be handled there.\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n    }\n\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return new PromiseImpl(function(resolve, reject) {\n          invoke(method, arg, resolve, reject);\n        });\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : callInvokeWithMethodAndArg();\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  });\n  exports.AsyncIterator = AsyncIterator;\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    if (PromiseImpl === void 0) PromiseImpl = Promise;\n\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList),\n      PromiseImpl\n    );\n\n    return exports.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      context.method = method;\n      context.arg = arg;\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n\n        if (context.method === \"next\") {\n          // Setting context._sent for legacy support of Babel's\n          // function.sent implementation.\n          context.sent = context._sent = context.arg;\n\n        } else if (context.method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw context.arg;\n          }\n\n          context.dispatchException(context.arg);\n\n        } else if (context.method === \"return\") {\n          context.abrupt(\"return\", context.arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          if (record.arg === ContinueSentinel) {\n            continue;\n          }\n\n          return {\n            value: record.arg,\n            done: context.done\n          };\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(context.arg) call above.\n          context.method = \"throw\";\n          context.arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Call delegate.iterator[context.method](context.arg) and handle the\n  // result, either by returning a { value, done } result from the\n  // delegate iterator, or by modifying context.method and context.arg,\n  // setting context.delegate to null, and returning the ContinueSentinel.\n  function maybeInvokeDelegate(delegate, context) {\n    var method = delegate.iterator[context.method];\n    if (method === undefined$1) {\n      // A .throw or .return when the delegate iterator has no .throw\n      // method always terminates the yield* loop.\n      context.delegate = null;\n\n      if (context.method === \"throw\") {\n        // Note: [\"return\"] must be used for ES3 parsing compatibility.\n        if (delegate.iterator[\"return\"]) {\n          // If the delegate iterator has a return method, give it a\n          // chance to clean up.\n          context.method = \"return\";\n          context.arg = undefined$1;\n          maybeInvokeDelegate(delegate, context);\n\n          if (context.method === \"throw\") {\n            // If maybeInvokeDelegate(context) changed context.method from\n            // \"return\" to \"throw\", let that override the TypeError below.\n            return ContinueSentinel;\n          }\n        }\n\n        context.method = \"throw\";\n        context.arg = new TypeError(\n          \"The iterator does not provide a 'throw' method\");\n      }\n\n      return ContinueSentinel;\n    }\n\n    var record = tryCatch(method, delegate.iterator, context.arg);\n\n    if (record.type === \"throw\") {\n      context.method = \"throw\";\n      context.arg = record.arg;\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    var info = record.arg;\n\n    if (! info) {\n      context.method = \"throw\";\n      context.arg = new TypeError(\"iterator result is not an object\");\n      context.delegate = null;\n      return ContinueSentinel;\n    }\n\n    if (info.done) {\n      // Assign the result of the finished delegate to the temporary\n      // variable specified by delegate.resultName (see delegateYield).\n      context[delegate.resultName] = info.value;\n\n      // Resume execution at the desired location (see delegateYield).\n      context.next = delegate.nextLoc;\n\n      // If context.method was \"throw\" but the delegate handled the\n      // exception, let the outer generator proceed normally. If\n      // context.method was \"next\", forget context.arg since it has been\n      // \"consumed\" by the delegate iterator. If context.method was\n      // \"return\", allow the original .return call to continue in the\n      // outer generator.\n      if (context.method !== \"return\") {\n        context.method = \"next\";\n        context.arg = undefined$1;\n      }\n\n    } else {\n      // Re-yield the result returned by the delegate method.\n      return info;\n    }\n\n    // The delegate iterator is finished, so forget it and continue with\n    // the outer generator.\n    context.delegate = null;\n    return ContinueSentinel;\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  define(Gp, toStringTagSymbol, \"Generator\");\n\n  // A Generator should always return itself as the iterator object when the\n  // @@iterator function is called on it. Some browsers' implementations of the\n  // iterator prototype chain incorrectly implement this, causing the Generator\n  // object to not be returned from this call. This ensures that doesn't happen.\n  // See https://github.com/facebook/regenerator/issues/274 for more details.\n  define(Gp, iteratorSymbol, function() {\n    return this;\n  });\n\n  define(Gp, \"toString\", function() {\n    return \"[object Generator]\";\n  });\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  exports.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined$1;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  exports.values = values;\n\n  function doneResult() {\n    return { value: undefined$1, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      // Resetting context._sent for legacy support of Babel's\n      // function.sent implementation.\n      this.sent = this._sent = undefined$1;\n      this.done = false;\n      this.delegate = null;\n\n      this.method = \"next\";\n      this.arg = undefined$1;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined$1;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n\n        if (caught) {\n          // If the dispatched exception was caught by a catch block,\n          // then let that catch block handle the exception normally.\n          context.method = \"next\";\n          context.arg = undefined$1;\n        }\n\n        return !! caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.method = \"next\";\n        this.next = finallyEntry.finallyLoc;\n        return ContinueSentinel;\n      }\n\n      return this.complete(record);\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = this.arg = record.arg;\n        this.method = \"return\";\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n\n      return ContinueSentinel;\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      if (this.method === \"next\") {\n        // Deliberately forget the last sent value so that we don't\n        // accidentally pass it on to the delegate.\n        this.arg = undefined$1;\n      }\n\n      return ContinueSentinel;\n    }\n  };\n\n  // Regardless of whether this script is executing as a CommonJS module\n  // or not, return the runtime object so that we can declare the variable\n  // regeneratorRuntime in the outer scope, which allows this module to be\n  // injected easily by `bin/regenerator --include-runtime script.js`.\n  return exports;\n\n}(\n  // If this script is executing as a CommonJS module, use module.exports\n  // as the regeneratorRuntime namespace. Otherwise create a new empty\n  // object. Either way, the resulting object will be used to initialize\n  // the regeneratorRuntime variable at the top of this file.\n  module.exports \n));\n\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  // This module should not be running in strict mode, so the above\n  // assignment should always work unless something is misconfigured. Just\n  // in case runtime.js accidentally runs in strict mode, in modern engines\n  // we can explicitly access globalThis. In older engines we can escape\n  // strict mode using a global Function call. This could conceivably fail\n  // if a Content Security Policy forbids using Function, but in that case\n  // the proper solution is to fix the accidental strict mode problem. If\n  // you've misconfigured your bundler to force strict mode and applied a\n  // CSP to forbid Function, and you're not willing to fix either of those\n  // problems, please detail your unique predicament in a GitHub issue.\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n}(runtime));\n\nvar _regeneratorRuntime = runtime.exports;\n\n/**\r\n * Generate SVG Path tag from the given points\r\n */\n\nvar SvgPath = function SvgPath(_ref) {\n  var paths = _ref.paths,\n      id = _ref.id,\n      strokeWidth = _ref.strokeWidth,\n      strokeColor = _ref.strokeColor,\n      _ref$command = _ref.command,\n      command = _ref$command === void 0 ? bezierCommand : _ref$command;\n\n  if (paths.length === 1) {\n    var _paths$ = paths[0],\n        x = _paths$.x,\n        y = _paths$.y;\n    var radius = strokeWidth / 2;\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", {\n      key: id,\n      id: id,\n      cx: x,\n      cy: y,\n      r: radius,\n      stroke: strokeColor,\n      fill: strokeColor\n    });\n  }\n\n  var d = paths.reduce(function (acc, point, i, a) {\n    return i === 0 ? \"M \" + point.x + \",\" + point.y : acc + \" \" + command(point, i, a);\n  }, '');\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", {\n    key: id,\n    id: id,\n    d: d,\n    fill: \"none\",\n    strokeLinecap: \"round\",\n    stroke: strokeColor,\n    strokeWidth: strokeWidth\n  });\n};\nvar line = function line(pointA, pointB) {\n  var lengthX = pointB.x - pointA.x;\n  var lengthY = pointB.y - pointA.y;\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n\nvar controlPoint = function controlPoint(controlPoints) {\n  var current = controlPoints.current,\n      next = controlPoints.next,\n      previous = controlPoints.previous,\n      reverse = controlPoints.reverse;\n  var p = previous || current;\n  var n = next || current;\n  var smoothing = 0.2;\n  var o = line(p, n);\n  var angle = o.angle + (reverse ? Math.PI : 0);\n  var length = o.length * smoothing;\n  var x = current.x + Math.cos(angle) * length;\n  var y = current.y + Math.sin(angle) * length;\n  return [x, y];\n};\n\nvar bezierCommand = function bezierCommand(point, i, a) {\n  var cpsX = null;\n  var cpsY = null;\n\n  switch (i) {\n    case 0:\n      var _controlPoint = controlPoint({\n        current: point\n      });\n\n      cpsX = _controlPoint[0];\n      cpsY = _controlPoint[1];\n      break;\n\n    case 1:\n      var _controlPoint2 = controlPoint({\n        current: a[i - 1],\n        next: point\n      });\n\n      cpsX = _controlPoint2[0];\n      cpsY = _controlPoint2[1];\n      break;\n\n    default:\n      var _controlPoint3 = controlPoint({\n        current: a[i - 1],\n        previous: a[i - 2],\n        next: point\n      });\n\n      cpsX = _controlPoint3[0];\n      cpsY = _controlPoint3[1];\n      break;\n  }\n\n  var _controlPoint4 = controlPoint({\n    current: point,\n    previous: a[i - 1],\n    next: a[i + 1],\n    reverse: true\n  }),\n      cpeX = _controlPoint4[0],\n      cpeY = _controlPoint4[1];\n\n  return \"C \" + cpsX + \",\" + cpsY + \" \" + cpeX + \",\" + cpeY + \" \" + point.x + \", \" + point.y;\n};\n\nvar Paths = function Paths(_ref2) {\n  var id = _ref2.id,\n      paths = _ref2.paths;\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, paths.map(function (path, index) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(SvgPath, {\n      key: id + \"__\" + index,\n      paths: path.paths,\n      id: id + \"__\" + index,\n      strokeWidth: path.strokeWidth,\n      strokeColor: path.strokeColor,\n      command: bezierCommand\n    });\n  }));\n};\n\nvar loadImage = function loadImage(url) {\n  return new Promise(function (resolve, reject) {\n    var img = new Image();\n    img.addEventListener('load', function () {\n      if (img.width > 0) {\n        resolve(img);\n      }\n\n      reject('Image not found');\n    });\n    img.addEventListener('error', function (err) {\n      return reject(err);\n    });\n    img.src = url;\n    img.setAttribute('crossorigin', 'anonymous');\n  });\n};\n\nfunction getCanvasWithViewBox(canvas) {\n  var _canvas$firstChild;\n\n  var svgCanvas = (_canvas$firstChild = canvas.firstChild) == null ? void 0 : _canvas$firstChild.cloneNode(true);\n  var width = canvas.offsetWidth;\n  var height = canvas.offsetHeight;\n  svgCanvas.setAttribute('viewBox', \"0 0 \" + width + \" \" + height);\n  svgCanvas.setAttribute('width', width.toString());\n  svgCanvas.setAttribute('height', height.toString());\n  return {\n    svgCanvas: svgCanvas,\n    width: width,\n    height: height\n  };\n}\n\nvar Canvas = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {\n  var paths = props.paths,\n      isDrawing = props.isDrawing,\n      onPointerDown = props.onPointerDown,\n      onPointerMove = props.onPointerMove,\n      onPointerUp = props.onPointerUp,\n      _props$id = props.id,\n      id = _props$id === void 0 ? 'react-sketch-canvas' : _props$id,\n      _props$width = props.width,\n      width = _props$width === void 0 ? '100%' : _props$width,\n      _props$height = props.height,\n      height = _props$height === void 0 ? '100%' : _props$height,\n      _props$className = props.className,\n      className = _props$className === void 0 ? 'react-sketch-canvas' : _props$className,\n      _props$canvasColor = props.canvasColor,\n      canvasColor = _props$canvasColor === void 0 ? 'red' : _props$canvasColor,\n      _props$backgroundImag = props.backgroundImage,\n      backgroundImage = _props$backgroundImag === void 0 ? '' : _props$backgroundImag,\n      _props$exportWithBack = props.exportWithBackgroundImage,\n      exportWithBackgroundImage = _props$exportWithBack === void 0 ? false : _props$exportWithBack,\n      _props$preserveBackgr = props.preserveBackgroundImageAspectRatio,\n      preserveBackgroundImageAspectRatio = _props$preserveBackgr === void 0 ? 'none' : _props$preserveBackgr,\n      _props$allowOnlyPoint = props.allowOnlyPointerType,\n      allowOnlyPointerType = _props$allowOnlyPoint === void 0 ? 'all' : _props$allowOnlyPoint,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {\n    border: '0.0625rem solid #9c9c9c',\n    borderRadius: '0.25rem'\n  } : _props$style,\n      _props$svgStyle = props.svgStyle,\n      svgStyle = _props$svgStyle === void 0 ? {} : _props$svgStyle;\n  var canvasRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null); // Converts mouse coordinates to relative coordinate based on the absolute position of svg\n\n  var getCoordinates = function getCoordinates(pointerEvent) {\n    var _canvasRef$current, _window$scrollX, _window$scrollY;\n\n    var boundingArea = (_canvasRef$current = canvasRef.current) == null ? void 0 : _canvasRef$current.getBoundingClientRect();\n    var scrollLeft = (_window$scrollX = window.scrollX) != null ? _window$scrollX : 0;\n    var scrollTop = (_window$scrollY = window.scrollY) != null ? _window$scrollY : 0;\n\n    if (!boundingArea) {\n      return {\n        x: 0,\n        y: 0\n      };\n    }\n\n    var point = {\n      x: pointerEvent.pageX - boundingArea.left - scrollLeft,\n      y: pointerEvent.pageY - boundingArea.top - scrollTop\n    };\n    return point;\n  };\n  /* Mouse Handlers - Mouse down, move and up */\n\n\n  var handlePointerDown = function handlePointerDown(event) {\n    // Allow only chosen pointer type\n    if (allowOnlyPointerType !== 'all' && event.pointerType !== allowOnlyPointerType) {\n      return;\n    }\n\n    if (event.pointerType === 'mouse' && event.button !== 0) return;\n    var point = getCoordinates(event);\n    onPointerDown(point);\n  };\n\n  var handlePointerMove = function handlePointerMove(event) {\n    if (!isDrawing) return; // Allow only chosen pointer type\n\n    if (allowOnlyPointerType !== 'all' && event.pointerType !== allowOnlyPointerType) {\n      return;\n    }\n\n    var point = getCoordinates(event);\n    onPointerMove(point);\n  };\n\n  var handlePointerUp = function handlePointerUp(event) {\n    if (event.pointerType === 'mouse' && event.button !== 0) return; // Allow only chosen pointer type\n\n    if (allowOnlyPointerType !== 'all' && event.pointerType !== allowOnlyPointerType) {\n      return;\n    }\n\n    onPointerUp();\n  };\n  /* Mouse Handlers ends */\n\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, function () {\n    return {\n      exportImage: function exportImage(imageType) {\n        return new Promise( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n            var canvas, _getCanvasWithViewBox, svgCanvas, _width, _height, canvasSketch, loadImagePromises, img;\n\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    _context.prev = 0;\n                    canvas = canvasRef.current;\n\n                    if (canvas) {\n                      _context.next = 4;\n                      break;\n                    }\n\n                    throw Error('Canvas not rendered yet');\n\n                  case 4:\n                    _getCanvasWithViewBox = getCanvasWithViewBox(canvas), svgCanvas = _getCanvasWithViewBox.svgCanvas, _width = _getCanvasWithViewBox.width, _height = _getCanvasWithViewBox.height;\n                    canvasSketch = \"data:image/svg+xml;base64,\" + btoa(svgCanvas.outerHTML);\n                    _context.next = 8;\n                    return loadImage(canvasSketch);\n\n                  case 8:\n                    _context.t0 = _context.sent;\n                    loadImagePromises = [_context.t0];\n\n                    if (!exportWithBackgroundImage) {\n                      _context.next = 21;\n                      break;\n                    }\n\n                    _context.prev = 11;\n                    _context.next = 14;\n                    return loadImage(backgroundImage);\n\n                  case 14:\n                    img = _context.sent;\n                    loadImagePromises.push(img);\n                    _context.next = 21;\n                    break;\n\n                  case 18:\n                    _context.prev = 18;\n                    _context.t1 = _context[\"catch\"](11);\n                    console.warn('exportWithBackgroundImage props is set without a valid background image URL. This option is ignored');\n\n                  case 21:\n                    Promise.all(loadImagePromises).then(function (images) {\n                      var renderCanvas = document.createElement('canvas');\n                      renderCanvas.setAttribute('width', _width.toString());\n                      renderCanvas.setAttribute('height', _height.toString());\n                      var context = renderCanvas.getContext('2d');\n\n                      if (!context) {\n                        throw Error('Canvas not rendered yet');\n                      }\n\n                      images.reverse().forEach(function (image) {\n                        context.drawImage(image, 0, 0);\n                      });\n                      resolve(renderCanvas.toDataURL(\"image/\" + imageType));\n                    })[\"catch\"](function (e) {\n                      throw e;\n                    });\n                    _context.next = 27;\n                    break;\n\n                  case 24:\n                    _context.prev = 24;\n                    _context.t2 = _context[\"catch\"](0);\n                    reject(_context.t2);\n\n                  case 27:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, null, [[0, 24], [11, 18]]);\n          }));\n\n          return function (_x, _x2) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n      },\n      exportSvg: function exportSvg() {\n        return new Promise(function (resolve, reject) {\n          try {\n            var _canvasRef$current2;\n\n            var canvas = (_canvasRef$current2 = canvasRef.current) != null ? _canvasRef$current2 : null;\n\n            if (canvas !== null) {\n              var _svgCanvas$querySelec, _svgCanvas$querySelec2;\n\n              var _getCanvasWithViewBox2 = getCanvasWithViewBox(canvas),\n                  svgCanvas = _getCanvasWithViewBox2.svgCanvas;\n\n              if (exportWithBackgroundImage) {\n                resolve(svgCanvas.outerHTML);\n                return;\n              }\n\n              (_svgCanvas$querySelec = svgCanvas.querySelector(\"#\" + id + \"__background\")) == null ? void 0 : _svgCanvas$querySelec.remove();\n              (_svgCanvas$querySelec2 = svgCanvas.querySelector(\"#\" + id + \"__canvas-background\")) == null ? void 0 : _svgCanvas$querySelec2.setAttribute('fill', canvasColor);\n              resolve(svgCanvas.outerHTML);\n            }\n\n            reject(new Error('Canvas not loaded'));\n          } catch (e) {\n            reject(e);\n          }\n        });\n      }\n    };\n  });\n  /* Add event listener to Mouse up and Touch up to\r\n  release drawing even when point goes out of canvas */\n\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    document.addEventListener('pointerup', handlePointerUp);\n    return function () {\n      document.removeEventListener('pointerup', handlePointerUp);\n    };\n  }, [handlePointerUp]);\n  var eraserPaths = paths.filter(function (path) {\n    return !path.drawMode;\n  });\n  var currentGroup = 0;\n  var pathGroups = paths.reduce(function (arrayGroup, path) {\n    if (!path.drawMode) {\n      currentGroup += 1;\n      return arrayGroup;\n    }\n\n    if (arrayGroup[currentGroup] === undefined) {\n      arrayGroup[currentGroup] = [];\n    }\n\n    arrayGroup[currentGroup].push(path);\n    return arrayGroup;\n  }, [[]]);\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", {\n    role: \"presentation\",\n    ref: canvasRef,\n    className: className,\n    style: _extends({\n      touchAction: 'none',\n      width: width,\n      height: height\n    }, style),\n    \"touch-action\": \"none\",\n    onPointerDown: handlePointerDown,\n    onPointerMove: handlePointerMove,\n    onPointerUp: handlePointerUp\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", {\n    version: \"1.1\",\n    baseProfile: \"full\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    xmlnsXlink: \"http://www.w3.org/1999/xlink\",\n    style: _extends({\n      width: '100%',\n      height: '100%'\n    }, svgStyle),\n    id: id\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    id: id + \"__eraser-stroke-group\",\n    display: \"none\"\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    id: id + \"__mask-background\",\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    fill: \"white\"\n  }), eraserPaths.map(function (eraserPath, i) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(SvgPath, {\n      key: id + \"__eraser-\" + i,\n      id: id + \"__eraser-\" + i,\n      paths: eraserPath.paths,\n      strokeColor: \"#000000\",\n      strokeWidth: eraserPath.strokeWidth\n    });\n  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null, backgroundImage && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"pattern\", {\n    id: id + \"__background\",\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    patternUnits: \"userSpaceOnUse\"\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"image\", {\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    xlinkHref: backgroundImage,\n    preserveAspectRatio: preserveBackgroundImageAspectRatio\n  })), eraserPaths.map(function (_, i) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"mask\", {\n      id: id + \"__eraser-mask-\" + i,\n      key: id + \"__eraser-mask-\" + i,\n      maskUnits: \"userSpaceOnUse\"\n    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"use\", {\n      href: \"#\" + id + \"__mask-background\"\n    }), Array.from({\n      length: eraserPaths.length - i\n    }, function (_, j) {\n      return j + i;\n    }).map(function (k) {\n      return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"use\", {\n        key: k.toString(),\n        href: \"#\" + id + \"__eraser-\" + k.toString()\n      });\n    }));\n  })), react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n    id: id + \"__canvas-background-group\"\n  }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", {\n    id: id + \"__canvas-background\",\n    x: \"0\",\n    y: \"0\",\n    width: \"100%\",\n    height: \"100%\",\n    fill: backgroundImage ? \"url(#\" + id + \"__background)\" : canvasColor\n  })), pathGroups.map(function (pathGroup, i) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", {\n      id: id + \"__stroke-group-\" + i,\n      key: id + \"__stroke-group-\" + i,\n      mask: \"url(#\" + id + \"__eraser-mask-\" + i + \")\"\n    }, react__WEBPACK_IMPORTED_MODULE_0__.createElement(Paths, {\n      id: id,\n      paths: pathGroup\n    }));\n  })));\n});\n\nvar ReactSketchCanvas = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.forwardRef(function (props, ref) {\n  var _props$id = props.id,\n      id = _props$id === void 0 ? 'react-sketch-canvas' : _props$id,\n      _props$width = props.width,\n      width = _props$width === void 0 ? '100%' : _props$width,\n      _props$height = props.height,\n      height = _props$height === void 0 ? '100%' : _props$height,\n      _props$className = props.className,\n      className = _props$className === void 0 ? '' : _props$className,\n      _props$canvasColor = props.canvasColor,\n      canvasColor = _props$canvasColor === void 0 ? 'white' : _props$canvasColor,\n      _props$strokeColor = props.strokeColor,\n      strokeColor = _props$strokeColor === void 0 ? 'red' : _props$strokeColor,\n      _props$backgroundImag = props.backgroundImage,\n      backgroundImage = _props$backgroundImag === void 0 ? '' : _props$backgroundImag,\n      _props$exportWithBack = props.exportWithBackgroundImage,\n      exportWithBackgroundImage = _props$exportWithBack === void 0 ? false : _props$exportWithBack,\n      _props$preserveBackgr = props.preserveBackgroundImageAspectRatio,\n      preserveBackgroundImageAspectRatio = _props$preserveBackgr === void 0 ? 'none' : _props$preserveBackgr,\n      _props$strokeWidth = props.strokeWidth,\n      strokeWidth = _props$strokeWidth === void 0 ? 4 : _props$strokeWidth,\n      _props$eraserWidth = props.eraserWidth,\n      eraserWidth = _props$eraserWidth === void 0 ? 8 : _props$eraserWidth,\n      _props$allowOnlyPoint = props.allowOnlyPointerType,\n      allowOnlyPointerType = _props$allowOnlyPoint === void 0 ? 'all' : _props$allowOnlyPoint,\n      _props$style = props.style,\n      style = _props$style === void 0 ? {\n    border: '0.0625rem solid #9c9c9c',\n    borderRadius: '0.25rem'\n  } : _props$style,\n      _props$svgStyle = props.svgStyle,\n      svgStyle = _props$svgStyle === void 0 ? {} : _props$svgStyle,\n      _props$onChange = props.onChange,\n      onChange = _props$onChange === void 0 ? function (_paths) {} : _props$onChange,\n      _props$onStroke = props.onStroke,\n      onStroke = _props$onStroke === void 0 ? function (_path, _isEraser) {} : _props$onStroke,\n      _props$withTimestamp = props.withTimestamp,\n      withTimestamp = _props$withTimestamp === void 0 ? false : _props$withTimestamp;\n  var svgCanvas = react__WEBPACK_IMPORTED_MODULE_0__.createRef();\n\n  var _React$useState = react__WEBPACK_IMPORTED_MODULE_0__.useState(true),\n      drawMode = _React$useState[0],\n      setDrawMode = _React$useState[1];\n\n  var _React$useState2 = react__WEBPACK_IMPORTED_MODULE_0__.useState(false),\n      isDrawing = _React$useState2[0],\n      setIsDrawing = _React$useState2[1];\n\n  var _React$useState3 = react__WEBPACK_IMPORTED_MODULE_0__.useState([]),\n      resetStack = _React$useState3[0],\n      setResetStack = _React$useState3[1];\n\n  var _React$useState4 = react__WEBPACK_IMPORTED_MODULE_0__.useState([]),\n      undoStack = _React$useState4[0],\n      setUndoStack = _React$useState4[1];\n\n  var _React$useState5 = react__WEBPACK_IMPORTED_MODULE_0__.useState([]),\n      currentPaths = _React$useState5[0],\n      setCurrentPaths = _React$useState5[1];\n\n  var liftStrokeUp = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(function () {\n    var _currentPaths$slice$, _currentPaths$slice;\n\n    var lastStroke = (_currentPaths$slice$ = (_currentPaths$slice = currentPaths.slice(-1)) == null ? void 0 : _currentPaths$slice[0]) != null ? _currentPaths$slice$ : null;\n\n    if (lastStroke === null) {\n      console.warn('No stroke found!');\n      return;\n    }\n\n    onStroke(lastStroke, !lastStroke.drawMode);\n  }, [isDrawing]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    liftStrokeUp();\n  }, [isDrawing]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useEffect(function () {\n    onChange(currentPaths);\n  }, [currentPaths]);\n  react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle(ref, function () {\n    return {\n      eraseMode: function eraseMode(erase) {\n        setDrawMode(!erase);\n      },\n      clearCanvas: function clearCanvas() {\n        setResetStack([].concat(currentPaths));\n        setCurrentPaths([]);\n      },\n      undo: function undo() {\n        // If there was a last reset then\n        if (resetStack.length !== 0) {\n          setCurrentPaths([].concat(resetStack));\n          setResetStack([]);\n          return;\n        }\n\n        setUndoStack(function (undoStack) {\n          return [].concat(undoStack, currentPaths.slice(-1));\n        });\n        setCurrentPaths(function (currentPaths) {\n          return currentPaths.slice(0, -1);\n        });\n      },\n      redo: function redo() {\n        // Nothing to Redo\n        if (undoStack.length === 0) return;\n        setCurrentPaths(function (currentPaths) {\n          return [].concat(currentPaths, undoStack.slice(-1));\n        });\n        setUndoStack(function (undoStack) {\n          return undoStack.slice(0, -1);\n        });\n      },\n      exportImage: function exportImage(imageType) {\n        var _svgCanvas$current;\n\n        var exportImage = (_svgCanvas$current = svgCanvas.current) == null ? void 0 : _svgCanvas$current.exportImage;\n\n        if (!exportImage) {\n          throw Error('Export function called before canvas loaded');\n        } else {\n          return exportImage(imageType);\n        }\n      },\n      exportSvg: function exportSvg() {\n        return new Promise(function (resolve, reject) {\n          var _svgCanvas$current2;\n\n          var exportSvg = (_svgCanvas$current2 = svgCanvas.current) == null ? void 0 : _svgCanvas$current2.exportSvg;\n\n          if (!exportSvg) {\n            reject(Error('Export function called before canvas loaded'));\n          } else {\n            exportSvg().then(function (data) {\n              resolve(data);\n            })[\"catch\"](function (e) {\n              reject(e);\n            });\n          }\n        });\n      },\n      exportPaths: function exportPaths() {\n        return new Promise(function (resolve, reject) {\n          try {\n            resolve(currentPaths);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n      loadPaths: function loadPaths(paths) {\n        setCurrentPaths(function (currentPaths) {\n          return [].concat(currentPaths, paths);\n        });\n      },\n      getSketchingTime: function getSketchingTime() {\n        return new Promise(function (resolve, reject) {\n          if (!withTimestamp) {\n            reject(new Error(\"Set 'withTimestamp' prop to get sketching time\"));\n          }\n\n          try {\n            var sketchingTime = currentPaths.reduce(function (totalSketchingTime, path) {\n              var _path$startTimestamp, _path$endTimestamp;\n\n              var startTimestamp = (_path$startTimestamp = path.startTimestamp) != null ? _path$startTimestamp : 0;\n              var endTimestamp = (_path$endTimestamp = path.endTimestamp) != null ? _path$endTimestamp : 0;\n              return totalSketchingTime + (endTimestamp - startTimestamp);\n            }, 0);\n            resolve(sketchingTime);\n          } catch (e) {\n            reject(e);\n          }\n        });\n      },\n      resetCanvas: function resetCanvas() {\n        setResetStack([]);\n        setUndoStack([]);\n        setCurrentPaths([]);\n      }\n    };\n  });\n\n  var handlePointerDown = function handlePointerDown(point) {\n    setIsDrawing(true);\n    setUndoStack([]);\n    var stroke = {\n      drawMode: drawMode,\n      strokeColor: drawMode ? strokeColor : '#000000',\n      strokeWidth: drawMode ? strokeWidth : eraserWidth,\n      paths: [point]\n    };\n\n    if (withTimestamp) {\n      stroke = _extends({}, stroke, {\n        startTimestamp: Date.now(),\n        endTimestamp: 0\n      });\n    }\n\n    setCurrentPaths(function (currentPaths) {\n      return [].concat(currentPaths, [stroke]);\n    });\n  };\n\n  var handlePointerMove = function handlePointerMove(point) {\n    if (!isDrawing) return;\n    var currentStroke = currentPaths.slice(-1)[0];\n\n    var updatedStroke = _extends({}, currentStroke, {\n      paths: [].concat(currentStroke.paths, [point])\n    });\n\n    setCurrentPaths(function (currentPaths) {\n      return [].concat(currentPaths.slice(0, -1), [updatedStroke]);\n    });\n  };\n\n  var handlePointerUp = function handlePointerUp() {\n    var _currentPaths$slice$2, _currentPaths$slice2;\n\n    if (!isDrawing) {\n      return;\n    }\n\n    setIsDrawing(false);\n\n    if (!withTimestamp) {\n      return;\n    }\n\n    var currentStroke = (_currentPaths$slice$2 = (_currentPaths$slice2 = currentPaths.slice(-1)) == null ? void 0 : _currentPaths$slice2[0]) != null ? _currentPaths$slice$2 : null;\n\n    if (currentStroke === null) {\n      return;\n    }\n\n    var updatedStroke = _extends({}, currentStroke, {\n      endTimestamp: Date.now()\n    });\n\n    setCurrentPaths(function (currentPaths) {\n      return [].concat(currentPaths.slice(0, -1), [updatedStroke]);\n    });\n  };\n\n  return react__WEBPACK_IMPORTED_MODULE_0__.createElement(Canvas, {\n    ref: svgCanvas,\n    id: id,\n    width: width,\n    height: height,\n    className: className,\n    canvasColor: canvasColor,\n    backgroundImage: backgroundImage,\n    exportWithBackgroundImage: exportWithBackgroundImage,\n    preserveBackgroundImageAspectRatio: preserveBackgroundImageAspectRatio,\n    allowOnlyPointerType: allowOnlyPointerType,\n    style: style,\n    svgStyle: svgStyle,\n    paths: currentPaths,\n    isDrawing: isDrawing,\n    onPointerDown: handlePointerDown,\n    onPointerMove: handlePointerMove,\n    onPointerUp: handlePointerUp\n  });\n});\n\n\n//# sourceMappingURL=react-sketch-canvas.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2tldGNoLWNhbnZhcy9kaXN0L3JlYWN0LXNrZXRjaC1jYW52YXMuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isc0JBQXNCO0FBQzFDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ04sZUFBZTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFVBQVU7QUFDVjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDLG1CQUFtQjtBQUNwRDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUEsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG1DQUFtQztBQUNuQztBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQSxTQUFTLGdEQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRW9DO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vMS1tb21lbnQtbWluaS1hcHAvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2tldGNoLWNhbnZhcy9kaXN0L3JlYWN0LXNrZXRjaC1jYW52YXMuZXNtLmpzPzkzOTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cblxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxudmFyIHJ1bnRpbWUgPSB7ZXhwb3J0czoge319O1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7XG52YXIgcnVudGltZSA9IChmdW5jdGlvbiAoZXhwb3J0cykge1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZCQxOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqW2tleV07XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBJRSA4IGhhcyBhIGJyb2tlbiBPYmplY3QuZGVmaW5lUHJvcGVydHkgdGhhdCBvbmx5IHdvcmtzIG9uIERPTSBvYmplY3RzLlxuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgICAgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBJZiBvdXRlckZuIHByb3ZpZGVkIGFuZCBvdXRlckZuLnByb3RvdHlwZSBpcyBhIEdlbmVyYXRvciwgdGhlbiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvci5cbiAgICB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvcjtcbiAgICB2YXIgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpO1xuICAgIHZhciBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pO1xuXG4gICAgLy8gVGhlIC5faW52b2tlIG1ldGhvZCB1bmlmaWVzIHRoZSBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlIC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcy5cbiAgICBnZW5lcmF0b3IuX2ludm9rZSA9IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7XG5cbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGV4cG9ydHMud3JhcCA9IHdyYXA7XG5cbiAgLy8gVHJ5L2NhdGNoIGhlbHBlciB0byBtaW5pbWl6ZSBkZW9wdGltaXphdGlvbnMuIFJldHVybnMgYSBjb21wbGV0aW9uXG4gIC8vIHJlY29yZCBsaWtlIGNvbnRleHQudHJ5RW50cmllc1tpXS5jb21wbGV0aW9uLiBUaGlzIGludGVyZmFjZSBjb3VsZFxuICAvLyBoYXZlIGJlZW4gKGFuZCB3YXMgcHJldmlvdXNseSkgZGVzaWduZWQgdG8gdGFrZSBhIGNsb3N1cmUgdG8gYmVcbiAgLy8gaW52b2tlZCB3aXRob3V0IGFyZ3VtZW50cywgYnV0IGluIGFsbCB0aGUgY2FzZXMgd2UgY2FyZSBhYm91dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYW4gZXhpc3RpbmcgbWV0aG9kIHdlIHdhbnQgdG8gY2FsbCwgc28gdGhlcmUncyBubyBuZWVkXG4gIC8vIHRvIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvYmplY3QuIFdlIGNhbiBldmVuIGdldCBhd2F5IHdpdGggYXNzdW1pbmdcbiAgLy8gdGhlIG1ldGhvZCB0YWtlcyBleGFjdGx5IG9uZSBhcmd1bWVudCwgc2luY2UgdGhhdCBoYXBwZW5zIHRvIGJlIHRydWVcbiAgLy8gaW4gZXZlcnkgY2FzZSwgc28gd2UgZG9uJ3QgaGF2ZSB0byB0b3VjaCB0aGUgYXJndW1lbnRzIG9iamVjdC4gVGhlXG4gIC8vIG9ubHkgYWRkaXRpb25hbCBhbGxvY2F0aW9uIHJlcXVpcmVkIGlzIHRoZSBjb21wbGV0aW9uIHJlY29yZCwgd2hpY2hcbiAgLy8gaGFzIGEgc3RhYmxlIHNoYXBlIGFuZCBzbyBob3BlZnVsbHkgc2hvdWxkIGJlIGNoZWFwIHRvIGFsbG9jYXRlLlxuICBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9O1xuICAgIH1cbiAgfVxuXG4gIHZhciBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0ID0gXCJzdXNwZW5kZWRTdGFydFwiO1xuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRZaWVsZCA9IFwic3VzcGVuZGVkWWllbGRcIjtcbiAgdmFyIEdlblN0YXRlRXhlY3V0aW5nID0gXCJleGVjdXRpbmdcIjtcbiAgdmFyIEdlblN0YXRlQ29tcGxldGVkID0gXCJjb21wbGV0ZWRcIjtcblxuICAvLyBSZXR1cm5pbmcgdGhpcyBvYmplY3QgZnJvbSB0aGUgaW5uZXJGbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzXG4gIC8vIGJyZWFraW5nIG91dCBvZiB0aGUgZGlzcGF0Y2ggc3dpdGNoIHN0YXRlbWVudC5cbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcblxuICAvLyBEdW1teSBjb25zdHJ1Y3RvciBmdW5jdGlvbnMgdGhhdCB3ZSB1c2UgYXMgdGhlIC5jb25zdHJ1Y3RvciBhbmRcbiAgLy8gLmNvbnN0cnVjdG9yLnByb3RvdHlwZSBwcm9wZXJ0aWVzIGZvciBmdW5jdGlvbnMgdGhhdCByZXR1cm4gR2VuZXJhdG9yXG4gIC8vIG9iamVjdHMuIEZvciBmdWxsIHNwZWMgY29tcGxpYW5jZSwgeW91IG1heSB3aXNoIHRvIGNvbmZpZ3VyZSB5b3VyXG4gIC8vIG1pbmlmaWVyIG5vdCB0byBtYW5nbGUgdGhlIG5hbWVzIG9mIHRoZXNlIHR3byBmdW5jdGlvbnMuXG4gIGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fVxuXG4gIC8vIFRoaXMgaXMgYSBwb2x5ZmlsbCBmb3IgJUl0ZXJhdG9yUHJvdG90eXBlJSBmb3IgZW52aXJvbm1lbnRzIHRoYXRcbiAgLy8gZG9uJ3QgbmF0aXZlbHkgc3VwcG9ydCBpdC5cbiAgdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG4gIGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZTtcbiAgZGVmaW5lKEdwLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIEdlbmVyYXRvckZ1bmN0aW9uKTtcbiAgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoXG4gICAgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgdG9TdHJpbmdUYWdTeW1ib2wsXG4gICAgXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICk7XG5cbiAgLy8gSGVscGVyIGZvciBkZWZpbmluZyB0aGUgLm5leHQsIC50aHJvdywgYW5kIC5yZXR1cm4gbWV0aG9kcyBvZiB0aGVcbiAgLy8gSXRlcmF0b3IgaW50ZXJmYWNlIGluIHRlcm1zIG9mIGEgc2luZ2xlIC5faW52b2tlIG1ldGhvZC5cbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkge1xuICAgIFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbihhcmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIik7XG4gICAgfVxuICAgIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKTtcbiAgICByZXR1cm4gZ2VuRnVuO1xuICB9O1xuXG4gIC8vIFdpdGhpbiB0aGUgYm9keSBvZiBhbnkgYXN5bmMgZnVuY3Rpb24sIGBhd2FpdCB4YCBpcyB0cmFuc2Zvcm1lZCB0b1xuICAvLyBgeWllbGQgcmVnZW5lcmF0b3JSdW50aW1lLmF3cmFwKHgpYCwgc28gdGhhdCB0aGUgcnVudGltZSBjYW4gdGVzdFxuICAvLyBgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKWAgdG8gZGV0ZXJtaW5lIGlmIHRoZSB5aWVsZGVkIHZhbHVlIGlzXG4gIC8vIG1lYW50IHRvIGJlIGF3YWl0ZWQuXG4gIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTtcbiAgfTtcblxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbih1bndyYXBwZWQpIHtcbiAgICAgICAgICAvLyBXaGVuIGEgeWllbGRlZCBQcm9taXNlIGlzIHJlc29sdmVkLCBpdHMgZmluYWwgdmFsdWUgYmVjb21lc1xuICAgICAgICAgIC8vIHRoZSAudmFsdWUgb2YgdGhlIFByb21pc2U8e3ZhbHVlLGRvbmV9PiByZXN1bHQgZm9yIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgaXRlcmF0aW9uLlxuICAgICAgICAgIHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZDtcbiAgICAgICAgICByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgLy8gSWYgYSByZWplY3RlZCBQcm9taXNlIHdhcyB5aWVsZGVkLCB0aHJvdyB0aGUgcmVqZWN0aW9uIGJhY2tcbiAgICAgICAgICAvLyBpbnRvIHRoZSBhc3luYyBnZW5lcmF0b3IgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGhhbmRsZWQgdGhlcmUuXG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcHJldmlvdXNQcm9taXNlO1xuXG4gICAgZnVuY3Rpb24gZW5xdWV1ZShtZXRob2QsIGFyZykge1xuICAgICAgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3I7XG5cbiAgLy8gTm90ZSB0aGF0IHNpbXBsZSBhc3luYyBmdW5jdGlvbnMgYXJlIGltcGxlbWVudGVkIG9uIHRvcCBvZlxuICAvLyBBc3luY0l0ZXJhdG9yIG9iamVjdHM7IHRoZXkganVzdCByZXR1cm4gYSBQcm9taXNlIGZvciB0aGUgdmFsdWUgb2ZcbiAgLy8gdGhlIGZpbmFsIHJlc3VsdCBwcm9kdWNlZCBieSB0aGUgaXRlcmF0b3IuXG4gIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbihpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICBpZiAoUHJvbWlzZUltcGwgPT09IHZvaWQgMCkgUHJvbWlzZUltcGwgPSBQcm9taXNlO1xuXG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLFxuICAgICAgUHJvbWlzZUltcGxcbiAgICApO1xuXG4gICAgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKVxuICAgICAgPyBpdGVyIC8vIElmIG91dGVyRm4gaXMgYSBnZW5lcmF0b3IsIHJldHVybiB0aGUgZnVsbCBpdGVyYXRvci5cbiAgICAgIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTtcbiAgICAgICAgfSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7XG4gICAgdmFyIHN0YXRlID0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydDtcblxuICAgIHJldHVybiBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVFeGVjdXRpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZUNvbXBsZXRlZCkge1xuICAgICAgICBpZiAobWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICB0aHJvdyBhcmc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCZSBmb3JnaXZpbmcsIHBlciAyNS4zLjMuMy4zIG9mIHRoZSBzcGVjOlxuICAgICAgICAvLyBodHRwczovL3Blb3BsZS5tb3ppbGxhLm9yZy9+am9yZW5kb3JmZi9lczYtZHJhZnQuaHRtbCNzZWMtZ2VuZXJhdG9ycmVzdW1lXG4gICAgICAgIHJldHVybiBkb25lUmVzdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQubWV0aG9kID0gbWV0aG9kO1xuICAgICAgY29udGV4dC5hcmcgPSBhcmc7XG5cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7XG4gICAgICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICAgIHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpO1xuICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCkge1xuICAgICAgICAgICAgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZVJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgICAgLy8gU2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgICBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgaWYgKHN0YXRlID09PSBHZW5TdGF0ZVN1c3BlbmRlZFN0YXJ0KSB7XG4gICAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgICAgdGhyb3cgY29udGV4dC5hcmc7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG5cbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJyZXR1cm5cIikge1xuICAgICAgICAgIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlID0gR2VuU3RhdGVFeGVjdXRpbmc7XG5cbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwibm9ybWFsXCIpIHtcbiAgICAgICAgICAvLyBJZiBhbiBleGNlcHRpb24gaXMgdGhyb3duIGZyb20gaW5uZXJGbiwgd2UgbGVhdmUgc3RhdGUgPT09XG4gICAgICAgICAgLy8gR2VuU3RhdGVFeGVjdXRpbmcgYW5kIGxvb3AgYmFjayBmb3IgYW5vdGhlciBpbnZvY2F0aW9uLlxuICAgICAgICAgIHN0YXRlID0gY29udGV4dC5kb25lXG4gICAgICAgICAgICA/IEdlblN0YXRlQ29tcGxldGVkXG4gICAgICAgICAgICA6IEdlblN0YXRlU3VzcGVuZGVkWWllbGQ7XG5cbiAgICAgICAgICBpZiAocmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlOiByZWNvcmQuYXJnLFxuICAgICAgICAgICAgZG9uZTogY29udGV4dC5kb25lXG4gICAgICAgICAgfTtcblxuICAgICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICBzdGF0ZSA9IEdlblN0YXRlQ29tcGxldGVkO1xuICAgICAgICAgIC8vIERpc3BhdGNoIHRoZSBleGNlcHRpb24gYnkgbG9vcGluZyBiYWNrIGFyb3VuZCB0byB0aGVcbiAgICAgICAgICAvLyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKSBjYWxsIGFib3ZlLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBDYWxsIGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXShjb250ZXh0LmFyZykgYW5kIGhhbmRsZSB0aGVcbiAgLy8gcmVzdWx0LCBlaXRoZXIgYnkgcmV0dXJuaW5nIGEgeyB2YWx1ZSwgZG9uZSB9IHJlc3VsdCBmcm9tIHRoZVxuICAvLyBkZWxlZ2F0ZSBpdGVyYXRvciwgb3IgYnkgbW9kaWZ5aW5nIGNvbnRleHQubWV0aG9kIGFuZCBjb250ZXh0LmFyZyxcbiAgLy8gc2V0dGluZyBjb250ZXh0LmRlbGVnYXRlIHRvIG51bGwsIGFuZCByZXR1cm5pbmcgdGhlIENvbnRpbnVlU2VudGluZWwuXG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbY29udGV4dC5tZXRob2RdO1xuICAgIGlmIChtZXRob2QgPT09IHVuZGVmaW5lZCQxKSB7XG4gICAgICAvLyBBIC50aHJvdyBvciAucmV0dXJuIHdoZW4gdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBubyAudGhyb3dcbiAgICAgIC8vIG1ldGhvZCBhbHdheXMgdGVybWluYXRlcyB0aGUgeWllbGQqIGxvb3AuXG4gICAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcInRocm93XCIpIHtcbiAgICAgICAgLy8gTm90ZTogW1wicmV0dXJuXCJdIG11c3QgYmUgdXNlZCBmb3IgRVMzIHBhcnNpbmcgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgaWYgKGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGhhcyBhIHJldHVybiBtZXRob2QsIGdpdmUgaXQgYVxuICAgICAgICAgIC8vIGNoYW5jZSB0byBjbGVhbiB1cC5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkJDE7XG4gICAgICB9XG5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmUteWllbGQgdGhlIHJlc3VsdCByZXR1cm5lZCBieSB0aGUgZGVsZWdhdGUgbWV0aG9kLlxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfVxuXG4gICAgLy8gVGhlIGRlbGVnYXRlIGl0ZXJhdG9yIGlzIGZpbmlzaGVkLCBzbyBmb3JnZXQgaXQgYW5kIGNvbnRpbnVlIHdpdGhcbiAgICAvLyB0aGUgb3V0ZXIgZ2VuZXJhdG9yLlxuICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICB9XG5cbiAgLy8gRGVmaW5lIEdlbmVyYXRvci5wcm90b3R5cGUue25leHQsdGhyb3cscmV0dXJufSBpbiB0ZXJtcyBvZiB0aGVcbiAgLy8gdW5pZmllZCAuX2ludm9rZSBoZWxwZXIgbWV0aG9kLlxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApO1xuXG4gIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuXG4gIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfSk7XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQkMSwgZG9uZTogdHJ1ZSB9O1xuICB9XG5cbiAgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG5cbiAgICByZXNldDogZnVuY3Rpb24oc2tpcFRlbXBSZXNldCkge1xuICAgICAgdGhpcy5wcmV2ID0gMDtcbiAgICAgIHRoaXMubmV4dCA9IDA7XG4gICAgICAvLyBSZXNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgLy8gZnVuY3Rpb24uc2VudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQkMTtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZCQxO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkJDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcblxuICAgICAgdmFyIHJvb3RFbnRyeSA9IHRoaXMudHJ5RW50cmllc1swXTtcbiAgICAgIHZhciByb290UmVjb3JkID0gcm9vdEVudHJ5LmNvbXBsZXRpb247XG4gICAgICBpZiAocm9vdFJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcm9vdFJlY29yZC5hcmc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcblxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbihleGNlcHRpb24pIHtcbiAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgdGhyb3cgZXhjZXB0aW9uO1xuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmVjb3JkLnR5cGUgPSBcInRocm93XCI7XG4gICAgICAgIHJlY29yZC5hcmcgPSBleGNlcHRpb247XG4gICAgICAgIGNvbnRleHQubmV4dCA9IGxvYztcblxuICAgICAgICBpZiAoY2F1Z2h0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIGRpc3BhdGNoZWQgZXhjZXB0aW9uIHdhcyBjYXVnaHQgYnkgYSBjYXRjaCBibG9jayxcbiAgICAgICAgICAvLyB0aGVuIGxldCB0aGF0IGNhdGNoIGJsb2NrIGhhbmRsZSB0aGUgZXhjZXB0aW9uIG5vcm1hbGx5LlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgICAgY29udGV4dC5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQkMTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICBtb2R1bGUuZXhwb3J0cyBcbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgaW4gbW9kZXJuIGVuZ2luZXNcbiAgLy8gd2UgY2FuIGV4cGxpY2l0bHkgYWNjZXNzIGdsb2JhbFRoaXMuIEluIG9sZGVyIGVuZ2luZXMgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiKSB7XG4gICAgZ2xvYmFsVGhpcy5yZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xuICB9IGVsc2Uge1xuICAgIEZ1bmN0aW9uKFwiclwiLCBcInJlZ2VuZXJhdG9yUnVudGltZSA9IHJcIikocnVudGltZSk7XG4gIH1cbn1cbn0ocnVudGltZSkpO1xuXG52YXIgX3JlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWUuZXhwb3J0cztcblxuLyoqXHJcbiAqIEdlbmVyYXRlIFNWRyBQYXRoIHRhZyBmcm9tIHRoZSBnaXZlbiBwb2ludHNcclxuICovXG5cbnZhciBTdmdQYXRoID0gZnVuY3Rpb24gU3ZnUGF0aChfcmVmKSB7XG4gIHZhciBwYXRocyA9IF9yZWYucGF0aHMsXG4gICAgICBpZCA9IF9yZWYuaWQsXG4gICAgICBzdHJva2VXaWR0aCA9IF9yZWYuc3Ryb2tlV2lkdGgsXG4gICAgICBzdHJva2VDb2xvciA9IF9yZWYuc3Ryb2tlQ29sb3IsXG4gICAgICBfcmVmJGNvbW1hbmQgPSBfcmVmLmNvbW1hbmQsXG4gICAgICBjb21tYW5kID0gX3JlZiRjb21tYW5kID09PSB2b2lkIDAgPyBiZXppZXJDb21tYW5kIDogX3JlZiRjb21tYW5kO1xuXG4gIGlmIChwYXRocy5sZW5ndGggPT09IDEpIHtcbiAgICB2YXIgX3BhdGhzJCA9IHBhdGhzWzBdLFxuICAgICAgICB4ID0gX3BhdGhzJC54LFxuICAgICAgICB5ID0gX3BhdGhzJC55O1xuICAgIHZhciByYWRpdXMgPSBzdHJva2VXaWR0aCAvIDI7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwge1xuICAgICAga2V5OiBpZCxcbiAgICAgIGlkOiBpZCxcbiAgICAgIGN4OiB4LFxuICAgICAgY3k6IHksXG4gICAgICByOiByYWRpdXMsXG4gICAgICBzdHJva2U6IHN0cm9rZUNvbG9yLFxuICAgICAgZmlsbDogc3Ryb2tlQ29sb3JcbiAgICB9KTtcbiAgfVxuXG4gIHZhciBkID0gcGF0aHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBvaW50LCBpLCBhKSB7XG4gICAgcmV0dXJuIGkgPT09IDAgPyBcIk0gXCIgKyBwb2ludC54ICsgXCIsXCIgKyBwb2ludC55IDogYWNjICsgXCIgXCIgKyBjb21tYW5kKHBvaW50LCBpLCBhKTtcbiAgfSwgJycpO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwge1xuICAgIGtleTogaWQsXG4gICAgaWQ6IGlkLFxuICAgIGQ6IGQsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgc3Ryb2tlTGluZWNhcDogXCJyb3VuZFwiLFxuICAgIHN0cm9rZTogc3Ryb2tlQ29sb3IsXG4gICAgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoXG4gIH0pO1xufTtcbnZhciBsaW5lID0gZnVuY3Rpb24gbGluZShwb2ludEEsIHBvaW50Qikge1xuICB2YXIgbGVuZ3RoWCA9IHBvaW50Qi54IC0gcG9pbnRBLng7XG4gIHZhciBsZW5ndGhZID0gcG9pbnRCLnkgLSBwb2ludEEueTtcbiAgcmV0dXJuIHtcbiAgICBsZW5ndGg6IE1hdGguc3FydChNYXRoLnBvdyhsZW5ndGhYLCAyKSArIE1hdGgucG93KGxlbmd0aFksIDIpKSxcbiAgICBhbmdsZTogTWF0aC5hdGFuMihsZW5ndGhZLCBsZW5ndGhYKVxuICB9O1xufTtcblxudmFyIGNvbnRyb2xQb2ludCA9IGZ1bmN0aW9uIGNvbnRyb2xQb2ludChjb250cm9sUG9pbnRzKSB7XG4gIHZhciBjdXJyZW50ID0gY29udHJvbFBvaW50cy5jdXJyZW50LFxuICAgICAgbmV4dCA9IGNvbnRyb2xQb2ludHMubmV4dCxcbiAgICAgIHByZXZpb3VzID0gY29udHJvbFBvaW50cy5wcmV2aW91cyxcbiAgICAgIHJldmVyc2UgPSBjb250cm9sUG9pbnRzLnJldmVyc2U7XG4gIHZhciBwID0gcHJldmlvdXMgfHwgY3VycmVudDtcbiAgdmFyIG4gPSBuZXh0IHx8IGN1cnJlbnQ7XG4gIHZhciBzbW9vdGhpbmcgPSAwLjI7XG4gIHZhciBvID0gbGluZShwLCBuKTtcbiAgdmFyIGFuZ2xlID0gby5hbmdsZSArIChyZXZlcnNlID8gTWF0aC5QSSA6IDApO1xuICB2YXIgbGVuZ3RoID0gby5sZW5ndGggKiBzbW9vdGhpbmc7XG4gIHZhciB4ID0gY3VycmVudC54ICsgTWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoO1xuICB2YXIgeSA9IGN1cnJlbnQueSArIE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aDtcbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbnZhciBiZXppZXJDb21tYW5kID0gZnVuY3Rpb24gYmV6aWVyQ29tbWFuZChwb2ludCwgaSwgYSkge1xuICB2YXIgY3BzWCA9IG51bGw7XG4gIHZhciBjcHNZID0gbnVsbDtcblxuICBzd2l0Y2ggKGkpIHtcbiAgICBjYXNlIDA6XG4gICAgICB2YXIgX2NvbnRyb2xQb2ludCA9IGNvbnRyb2xQb2ludCh7XG4gICAgICAgIGN1cnJlbnQ6IHBvaW50XG4gICAgICB9KTtcblxuICAgICAgY3BzWCA9IF9jb250cm9sUG9pbnRbMF07XG4gICAgICBjcHNZID0gX2NvbnRyb2xQb2ludFsxXTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAxOlxuICAgICAgdmFyIF9jb250cm9sUG9pbnQyID0gY29udHJvbFBvaW50KHtcbiAgICAgICAgY3VycmVudDogYVtpIC0gMV0sXG4gICAgICAgIG5leHQ6IHBvaW50XG4gICAgICB9KTtcblxuICAgICAgY3BzWCA9IF9jb250cm9sUG9pbnQyWzBdO1xuICAgICAgY3BzWSA9IF9jb250cm9sUG9pbnQyWzFdO1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIF9jb250cm9sUG9pbnQzID0gY29udHJvbFBvaW50KHtcbiAgICAgICAgY3VycmVudDogYVtpIC0gMV0sXG4gICAgICAgIHByZXZpb3VzOiBhW2kgLSAyXSxcbiAgICAgICAgbmV4dDogcG9pbnRcbiAgICAgIH0pO1xuXG4gICAgICBjcHNYID0gX2NvbnRyb2xQb2ludDNbMF07XG4gICAgICBjcHNZID0gX2NvbnRyb2xQb2ludDNbMV07XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBfY29udHJvbFBvaW50NCA9IGNvbnRyb2xQb2ludCh7XG4gICAgY3VycmVudDogcG9pbnQsXG4gICAgcHJldmlvdXM6IGFbaSAtIDFdLFxuICAgIG5leHQ6IGFbaSArIDFdLFxuICAgIHJldmVyc2U6IHRydWVcbiAgfSksXG4gICAgICBjcGVYID0gX2NvbnRyb2xQb2ludDRbMF0sXG4gICAgICBjcGVZID0gX2NvbnRyb2xQb2ludDRbMV07XG5cbiAgcmV0dXJuIFwiQyBcIiArIGNwc1ggKyBcIixcIiArIGNwc1kgKyBcIiBcIiArIGNwZVggKyBcIixcIiArIGNwZVkgKyBcIiBcIiArIHBvaW50LnggKyBcIiwgXCIgKyBwb2ludC55O1xufTtcblxudmFyIFBhdGhzID0gZnVuY3Rpb24gUGF0aHMoX3JlZjIpIHtcbiAgdmFyIGlkID0gX3JlZjIuaWQsXG4gICAgICBwYXRocyA9IF9yZWYyLnBhdGhzO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcGF0aHMubWFwKGZ1bmN0aW9uIChwYXRoLCBpbmRleCkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFN2Z1BhdGgsIHtcbiAgICAgIGtleTogaWQgKyBcIl9fXCIgKyBpbmRleCxcbiAgICAgIHBhdGhzOiBwYXRoLnBhdGhzLFxuICAgICAgaWQ6IGlkICsgXCJfX1wiICsgaW5kZXgsXG4gICAgICBzdHJva2VXaWR0aDogcGF0aC5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZUNvbG9yOiBwYXRoLnN0cm9rZUNvbG9yLFxuICAgICAgY29tbWFuZDogYmV6aWVyQ29tbWFuZFxuICAgIH0pO1xuICB9KSk7XG59O1xuXG52YXIgbG9hZEltYWdlID0gZnVuY3Rpb24gbG9hZEltYWdlKHVybCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpbWcud2lkdGggPiAwKSB7XG4gICAgICAgIHJlc29sdmUoaW1nKTtcbiAgICAgIH1cblxuICAgICAgcmVqZWN0KCdJbWFnZSBub3QgZm91bmQnKTtcbiAgICB9KTtcbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgfSk7XG4gICAgaW1nLnNyYyA9IHVybDtcbiAgICBpbWcuc2V0QXR0cmlidXRlKCdjcm9zc29yaWdpbicsICdhbm9ueW1vdXMnKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBnZXRDYW52YXNXaXRoVmlld0JveChjYW52YXMpIHtcbiAgdmFyIF9jYW52YXMkZmlyc3RDaGlsZDtcblxuICB2YXIgc3ZnQ2FudmFzID0gKF9jYW52YXMkZmlyc3RDaGlsZCA9IGNhbnZhcy5maXJzdENoaWxkKSA9PSBudWxsID8gdm9pZCAwIDogX2NhbnZhcyRmaXJzdENoaWxkLmNsb25lTm9kZSh0cnVlKTtcbiAgdmFyIHdpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoO1xuICB2YXIgaGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodDtcbiAgc3ZnQ2FudmFzLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFwiMCAwIFwiICsgd2lkdGggKyBcIiBcIiArIGhlaWdodCk7XG4gIHN2Z0NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgudG9TdHJpbmcoKSk7XG4gIHN2Z0NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodC50b1N0cmluZygpKTtcbiAgcmV0dXJuIHtcbiAgICBzdmdDYW52YXM6IHN2Z0NhbnZhcyxcbiAgICB3aWR0aDogd2lkdGgsXG4gICAgaGVpZ2h0OiBoZWlnaHRcbiAgfTtcbn1cblxudmFyIENhbnZhcyA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIChwcm9wcywgcmVmKSB7XG4gIHZhciBwYXRocyA9IHByb3BzLnBhdGhzLFxuICAgICAgaXNEcmF3aW5nID0gcHJvcHMuaXNEcmF3aW5nLFxuICAgICAgb25Qb2ludGVyRG93biA9IHByb3BzLm9uUG9pbnRlckRvd24sXG4gICAgICBvblBvaW50ZXJNb3ZlID0gcHJvcHMub25Qb2ludGVyTW92ZSxcbiAgICAgIG9uUG9pbnRlclVwID0gcHJvcHMub25Qb2ludGVyVXAsXG4gICAgICBfcHJvcHMkaWQgPSBwcm9wcy5pZCxcbiAgICAgIGlkID0gX3Byb3BzJGlkID09PSB2b2lkIDAgPyAncmVhY3Qtc2tldGNoLWNhbnZhcycgOiBfcHJvcHMkaWQsXG4gICAgICBfcHJvcHMkd2lkdGggPSBwcm9wcy53aWR0aCxcbiAgICAgIHdpZHRoID0gX3Byb3BzJHdpZHRoID09PSB2b2lkIDAgPyAnMTAwJScgOiBfcHJvcHMkd2lkdGgsXG4gICAgICBfcHJvcHMkaGVpZ2h0ID0gcHJvcHMuaGVpZ2h0LFxuICAgICAgaGVpZ2h0ID0gX3Byb3BzJGhlaWdodCA9PT0gdm9pZCAwID8gJzEwMCUnIDogX3Byb3BzJGhlaWdodCxcbiAgICAgIF9wcm9wcyRjbGFzc05hbWUgPSBwcm9wcy5jbGFzc05hbWUsXG4gICAgICBjbGFzc05hbWUgPSBfcHJvcHMkY2xhc3NOYW1lID09PSB2b2lkIDAgPyAncmVhY3Qtc2tldGNoLWNhbnZhcycgOiBfcHJvcHMkY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNhbnZhc0NvbG9yID0gcHJvcHMuY2FudmFzQ29sb3IsXG4gICAgICBjYW52YXNDb2xvciA9IF9wcm9wcyRjYW52YXNDb2xvciA9PT0gdm9pZCAwID8gJ3JlZCcgOiBfcHJvcHMkY2FudmFzQ29sb3IsXG4gICAgICBfcHJvcHMkYmFja2dyb3VuZEltYWcgPSBwcm9wcy5iYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICBiYWNrZ3JvdW5kSW1hZ2UgPSBfcHJvcHMkYmFja2dyb3VuZEltYWcgPT09IHZvaWQgMCA/ICcnIDogX3Byb3BzJGJhY2tncm91bmRJbWFnLFxuICAgICAgX3Byb3BzJGV4cG9ydFdpdGhCYWNrID0gcHJvcHMuZXhwb3J0V2l0aEJhY2tncm91bmRJbWFnZSxcbiAgICAgIGV4cG9ydFdpdGhCYWNrZ3JvdW5kSW1hZ2UgPSBfcHJvcHMkZXhwb3J0V2l0aEJhY2sgPT09IHZvaWQgMCA/IGZhbHNlIDogX3Byb3BzJGV4cG9ydFdpdGhCYWNrLFxuICAgICAgX3Byb3BzJHByZXNlcnZlQmFja2dyID0gcHJvcHMucHJlc2VydmVCYWNrZ3JvdW5kSW1hZ2VBc3BlY3RSYXRpbyxcbiAgICAgIHByZXNlcnZlQmFja2dyb3VuZEltYWdlQXNwZWN0UmF0aW8gPSBfcHJvcHMkcHJlc2VydmVCYWNrZ3IgPT09IHZvaWQgMCA/ICdub25lJyA6IF9wcm9wcyRwcmVzZXJ2ZUJhY2tncixcbiAgICAgIF9wcm9wcyRhbGxvd09ubHlQb2ludCA9IHByb3BzLmFsbG93T25seVBvaW50ZXJUeXBlLFxuICAgICAgYWxsb3dPbmx5UG9pbnRlclR5cGUgPSBfcHJvcHMkYWxsb3dPbmx5UG9pbnQgPT09IHZvaWQgMCA/ICdhbGwnIDogX3Byb3BzJGFsbG93T25seVBvaW50LFxuICAgICAgX3Byb3BzJHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBzdHlsZSA9IF9wcm9wcyRzdHlsZSA9PT0gdm9pZCAwID8ge1xuICAgIGJvcmRlcjogJzAuMDYyNXJlbSBzb2xpZCAjOWM5YzljJyxcbiAgICBib3JkZXJSYWRpdXM6ICcwLjI1cmVtJ1xuICB9IDogX3Byb3BzJHN0eWxlLFxuICAgICAgX3Byb3BzJHN2Z1N0eWxlID0gcHJvcHMuc3ZnU3R5bGUsXG4gICAgICBzdmdTdHlsZSA9IF9wcm9wcyRzdmdTdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkc3ZnU3R5bGU7XG4gIHZhciBjYW52YXNSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7IC8vIENvbnZlcnRzIG1vdXNlIGNvb3JkaW5hdGVzIHRvIHJlbGF0aXZlIGNvb3JkaW5hdGUgYmFzZWQgb24gdGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHN2Z1xuXG4gIHZhciBnZXRDb29yZGluYXRlcyA9IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVzKHBvaW50ZXJFdmVudCkge1xuICAgIHZhciBfY2FudmFzUmVmJGN1cnJlbnQsIF93aW5kb3ckc2Nyb2xsWCwgX3dpbmRvdyRzY3JvbGxZO1xuXG4gICAgdmFyIGJvdW5kaW5nQXJlYSA9IChfY2FudmFzUmVmJGN1cnJlbnQgPSBjYW52YXNSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jYW52YXNSZWYkY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IChfd2luZG93JHNjcm9sbFggPSB3aW5kb3cuc2Nyb2xsWCkgIT0gbnVsbCA/IF93aW5kb3ckc2Nyb2xsWCA6IDA7XG4gICAgdmFyIHNjcm9sbFRvcCA9IChfd2luZG93JHNjcm9sbFkgPSB3aW5kb3cuc2Nyb2xsWSkgIT0gbnVsbCA/IF93aW5kb3ckc2Nyb2xsWSA6IDA7XG5cbiAgICBpZiAoIWJvdW5kaW5nQXJlYSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogMCxcbiAgICAgICAgeTogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQgPSB7XG4gICAgICB4OiBwb2ludGVyRXZlbnQucGFnZVggLSBib3VuZGluZ0FyZWEubGVmdCAtIHNjcm9sbExlZnQsXG4gICAgICB5OiBwb2ludGVyRXZlbnQucGFnZVkgLSBib3VuZGluZ0FyZWEudG9wIC0gc2Nyb2xsVG9wXG4gICAgfTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH07XG4gIC8qIE1vdXNlIEhhbmRsZXJzIC0gTW91c2UgZG93biwgbW92ZSBhbmQgdXAgKi9cblxuXG4gIHZhciBoYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKGV2ZW50KSB7XG4gICAgLy8gQWxsb3cgb25seSBjaG9zZW4gcG9pbnRlciB0eXBlXG4gICAgaWYgKGFsbG93T25seVBvaW50ZXJUeXBlICE9PSAnYWxsJyAmJiBldmVudC5wb2ludGVyVHlwZSAhPT0gYWxsb3dPbmx5UG9pbnRlclR5cGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgJiYgZXZlbnQuYnV0dG9uICE9PSAwKSByZXR1cm47XG4gICAgdmFyIHBvaW50ID0gZ2V0Q29vcmRpbmF0ZXMoZXZlbnQpO1xuICAgIG9uUG9pbnRlckRvd24ocG9pbnQpO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb2ludGVyTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlKGV2ZW50KSB7XG4gICAgaWYgKCFpc0RyYXdpbmcpIHJldHVybjsgLy8gQWxsb3cgb25seSBjaG9zZW4gcG9pbnRlciB0eXBlXG5cbiAgICBpZiAoYWxsb3dPbmx5UG9pbnRlclR5cGUgIT09ICdhbGwnICYmIGV2ZW50LnBvaW50ZXJUeXBlICE9PSBhbGxvd09ubHlQb2ludGVyVHlwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwb2ludCA9IGdldENvb3JkaW5hdGVzKGV2ZW50KTtcbiAgICBvblBvaW50ZXJNb3ZlKHBvaW50KTtcbiAgfTtcblxuICB2YXIgaGFuZGxlUG9pbnRlclVwID0gZnVuY3Rpb24gaGFuZGxlUG9pbnRlclVwKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnBvaW50ZXJUeXBlID09PSAnbW91c2UnICYmIGV2ZW50LmJ1dHRvbiAhPT0gMCkgcmV0dXJuOyAvLyBBbGxvdyBvbmx5IGNob3NlbiBwb2ludGVyIHR5cGVcblxuICAgIGlmIChhbGxvd09ubHlQb2ludGVyVHlwZSAhPT0gJ2FsbCcgJiYgZXZlbnQucG9pbnRlclR5cGUgIT09IGFsbG93T25seVBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb25Qb2ludGVyVXAoKTtcbiAgfTtcbiAgLyogTW91c2UgSGFuZGxlcnMgZW5kcyAqL1xuXG5cbiAgUmVhY3QudXNlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXhwb3J0SW1hZ2U6IGZ1bmN0aW9uIGV4cG9ydEltYWdlKGltYWdlVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdmFyIF9yZWYgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUubWFyayhmdW5jdGlvbiBfY2FsbGVlKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcywgX2dldENhbnZhc1dpdGhWaWV3Qm94LCBzdmdDYW52YXMsIF93aWR0aCwgX2hlaWdodCwgY2FudmFzU2tldGNoLCBsb2FkSW1hZ2VQcm9taXNlcywgaW1nO1xuXG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbnZhcykge1xuICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0NhbnZhcyBub3QgcmVuZGVyZWQgeWV0Jyk7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgX2dldENhbnZhc1dpdGhWaWV3Qm94ID0gZ2V0Q2FudmFzV2l0aFZpZXdCb3goY2FudmFzKSwgc3ZnQ2FudmFzID0gX2dldENhbnZhc1dpdGhWaWV3Qm94LnN2Z0NhbnZhcywgX3dpZHRoID0gX2dldENhbnZhc1dpdGhWaWV3Qm94LndpZHRoLCBfaGVpZ2h0ID0gX2dldENhbnZhc1dpdGhWaWV3Qm94LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzU2tldGNoID0gXCJkYXRhOmltYWdlL3N2Zyt4bWw7YmFzZTY0LFwiICsgYnRvYShzdmdDYW52YXMub3V0ZXJIVE1MKTtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2FkSW1hZ2UoY2FudmFzU2tldGNoKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC50MCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGxvYWRJbWFnZVByb21pc2VzID0gW19jb250ZXh0LnQwXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWV4cG9ydFdpdGhCYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjE7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTE7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvYWRJbWFnZShiYWNrZ3JvdW5kSW1hZ2UpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICAgICAgICBpbWcgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICAgICAgICBsb2FkSW1hZ2VQcm9taXNlcy5wdXNoKGltZyk7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAxODtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDEgPSBfY29udGV4dFtcImNhdGNoXCJdKDExKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdleHBvcnRXaXRoQmFja2dyb3VuZEltYWdlIHByb3BzIGlzIHNldCB3aXRob3V0IGEgdmFsaWQgYmFja2dyb3VuZCBpbWFnZSBVUkwuIFRoaXMgb3B0aW9uIGlzIGlnbm9yZWQnKTtcblxuICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwobG9hZEltYWdlUHJvbWlzZXMpLnRoZW4oZnVuY3Rpb24gKGltYWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgIHZhciByZW5kZXJDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsIF93aWR0aC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICByZW5kZXJDYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBfaGVpZ2h0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBjb250ZXh0ID0gcmVuZGVyQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKCdDYW52YXMgbm90IHJlbmRlcmVkIHlldCcpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgIGltYWdlcy5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbiAoaW1hZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltYWdlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlbmRlckNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9cIiArIGltYWdlVHlwZSkpO1xuICAgICAgICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyNztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSAyNDtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQudDIgPSBfY29udGV4dFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoX2NvbnRleHQudDIpO1xuXG4gICAgICAgICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgX2NhbGxlZSwgbnVsbCwgW1swLCAyNF0sIFsxMSwgMThdXSk7XG4gICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeCwgX3gyKSB7XG4gICAgICAgICAgICByZXR1cm4gX3JlZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0oKSk7XG4gICAgICB9LFxuICAgICAgZXhwb3J0U3ZnOiBmdW5jdGlvbiBleHBvcnRTdmcoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfY2FudmFzUmVmJGN1cnJlbnQyO1xuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gKF9jYW52YXNSZWYkY3VycmVudDIgPSBjYW52YXNSZWYuY3VycmVudCkgIT0gbnVsbCA/IF9jYW52YXNSZWYkY3VycmVudDIgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAoY2FudmFzICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMsIF9zdmdDYW52YXMkcXVlcnlTZWxlYzI7XG5cbiAgICAgICAgICAgICAgdmFyIF9nZXRDYW52YXNXaXRoVmlld0JveDIgPSBnZXRDYW52YXNXaXRoVmlld0JveChjYW52YXMpLFxuICAgICAgICAgICAgICAgICAgc3ZnQ2FudmFzID0gX2dldENhbnZhc1dpdGhWaWV3Qm94Mi5zdmdDYW52YXM7XG5cbiAgICAgICAgICAgICAgaWYgKGV4cG9ydFdpdGhCYWNrZ3JvdW5kSW1hZ2UpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHN2Z0NhbnZhcy5vdXRlckhUTUwpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIChfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMgPSBzdmdDYW52YXMucXVlcnlTZWxlY3RvcihcIiNcIiArIGlkICsgXCJfX2JhY2tncm91bmRcIikpID09IG51bGwgPyB2b2lkIDAgOiBfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIChfc3ZnQ2FudmFzJHF1ZXJ5U2VsZWMyID0gc3ZnQ2FudmFzLnF1ZXJ5U2VsZWN0b3IoXCIjXCIgKyBpZCArIFwiX19jYW52YXMtYmFja2dyb3VuZFwiKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdmdDYW52YXMkcXVlcnlTZWxlYzIuc2V0QXR0cmlidXRlKCdmaWxsJywgY2FudmFzQ29sb3IpO1xuICAgICAgICAgICAgICByZXNvbHZlKHN2Z0NhbnZhcy5vdXRlckhUTUwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKCdDYW52YXMgbm90IGxvYWRlZCcpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbiAgLyogQWRkIGV2ZW50IGxpc3RlbmVyIHRvIE1vdXNlIHVwIGFuZCBUb3VjaCB1cCB0b1xyXG4gIHJlbGVhc2UgZHJhd2luZyBldmVuIHdoZW4gcG9pbnQgZ29lcyBvdXQgb2YgY2FudmFzICovXG5cbiAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBoYW5kbGVQb2ludGVyVXApO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdwb2ludGVydXAnLCBoYW5kbGVQb2ludGVyVXApO1xuICAgIH07XG4gIH0sIFtoYW5kbGVQb2ludGVyVXBdKTtcbiAgdmFyIGVyYXNlclBhdGhzID0gcGF0aHMuZmlsdGVyKGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgcmV0dXJuICFwYXRoLmRyYXdNb2RlO1xuICB9KTtcbiAgdmFyIGN1cnJlbnRHcm91cCA9IDA7XG4gIHZhciBwYXRoR3JvdXBzID0gcGF0aHMucmVkdWNlKGZ1bmN0aW9uIChhcnJheUdyb3VwLCBwYXRoKSB7XG4gICAgaWYgKCFwYXRoLmRyYXdNb2RlKSB7XG4gICAgICBjdXJyZW50R3JvdXAgKz0gMTtcbiAgICAgIHJldHVybiBhcnJheUdyb3VwO1xuICAgIH1cblxuICAgIGlmIChhcnJheUdyb3VwW2N1cnJlbnRHcm91cF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXJyYXlHcm91cFtjdXJyZW50R3JvdXBdID0gW107XG4gICAgfVxuXG4gICAgYXJyYXlHcm91cFtjdXJyZW50R3JvdXBdLnB1c2gocGF0aCk7XG4gICAgcmV0dXJuIGFycmF5R3JvdXA7XG4gIH0sIFtbXV0pO1xuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgcm9sZTogXCJwcmVzZW50YXRpb25cIixcbiAgICByZWY6IGNhbnZhc1JlZixcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0XG4gICAgfSwgc3R5bGUpLFxuICAgIFwidG91Y2gtYWN0aW9uXCI6IFwibm9uZVwiLFxuICAgIG9uUG9pbnRlckRvd246IGhhbmRsZVBvaW50ZXJEb3duLFxuICAgIG9uUG9pbnRlck1vdmU6IGhhbmRsZVBvaW50ZXJNb3ZlLFxuICAgIG9uUG9pbnRlclVwOiBoYW5kbGVQb2ludGVyVXBcbiAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7XG4gICAgdmVyc2lvbjogXCIxLjFcIixcbiAgICBiYXNlUHJvZmlsZTogXCJmdWxsXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB4bWxuc1hsaW5rOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIixcbiAgICBzdHlsZTogX2V4dGVuZHMoe1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgfSwgc3ZnU3R5bGUpLFxuICAgIGlkOiBpZFxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgaWQ6IGlkICsgXCJfX2VyYXNlci1zdHJva2UtZ3JvdXBcIixcbiAgICBkaXNwbGF5OiBcIm5vbmVcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgaWQ6IGlkICsgXCJfX21hc2stYmFja2dyb3VuZFwiLFxuICAgIHg6IFwiMFwiLFxuICAgIHk6IFwiMFwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIGZpbGw6IFwid2hpdGVcIlxuICB9KSwgZXJhc2VyUGF0aHMubWFwKGZ1bmN0aW9uIChlcmFzZXJQYXRoLCBpKSB7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoU3ZnUGF0aCwge1xuICAgICAga2V5OiBpZCArIFwiX19lcmFzZXItXCIgKyBpLFxuICAgICAgaWQ6IGlkICsgXCJfX2VyYXNlci1cIiArIGksXG4gICAgICBwYXRoczogZXJhc2VyUGF0aC5wYXRocyxcbiAgICAgIHN0cm9rZUNvbG9yOiBcIiMwMDAwMDBcIixcbiAgICAgIHN0cm9rZVdpZHRoOiBlcmFzZXJQYXRoLnN0cm9rZVdpZHRoXG4gICAgfSk7XG4gIH0pKSwgUmVhY3QuY3JlYXRlRWxlbWVudChcImRlZnNcIiwgbnVsbCwgYmFja2dyb3VuZEltYWdlICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXR0ZXJuXCIsIHtcbiAgICBpZDogaWQgKyBcIl9fYmFja2dyb3VuZFwiLFxuICAgIHg6IFwiMFwiLFxuICAgIHk6IFwiMFwiLFxuICAgIHdpZHRoOiBcIjEwMCVcIixcbiAgICBoZWlnaHQ6IFwiMTAwJVwiLFxuICAgIHBhdHRlcm5Vbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWFnZVwiLCB7XG4gICAgeDogXCIwXCIsXG4gICAgeTogXCIwXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgeGxpbmtIcmVmOiBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogcHJlc2VydmVCYWNrZ3JvdW5kSW1hZ2VBc3BlY3RSYXRpb1xuICB9KSksIGVyYXNlclBhdGhzLm1hcChmdW5jdGlvbiAoXywgaSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwibWFza1wiLCB7XG4gICAgICBpZDogaWQgKyBcIl9fZXJhc2VyLW1hc2stXCIgKyBpLFxuICAgICAga2V5OiBpZCArIFwiX19lcmFzZXItbWFzay1cIiArIGksXG4gICAgICBtYXNrVW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgIH0sIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1c2VcIiwge1xuICAgICAgaHJlZjogXCIjXCIgKyBpZCArIFwiX19tYXNrLWJhY2tncm91bmRcIlxuICAgIH0pLCBBcnJheS5mcm9tKHtcbiAgICAgIGxlbmd0aDogZXJhc2VyUGF0aHMubGVuZ3RoIC0gaVxuICAgIH0sIGZ1bmN0aW9uIChfLCBqKSB7XG4gICAgICByZXR1cm4gaiArIGk7XG4gICAgfSkubWFwKGZ1bmN0aW9uIChrKSB7XG4gICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcInVzZVwiLCB7XG4gICAgICAgIGtleTogay50b1N0cmluZygpLFxuICAgICAgICBocmVmOiBcIiNcIiArIGlkICsgXCJfX2VyYXNlci1cIiArIGsudG9TdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfSkpO1xuICB9KSksIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJnXCIsIHtcbiAgICBpZDogaWQgKyBcIl9fY2FudmFzLWJhY2tncm91bmQtZ3JvdXBcIlxuICB9LCBSZWFjdC5jcmVhdGVFbGVtZW50KFwicmVjdFwiLCB7XG4gICAgaWQ6IGlkICsgXCJfX2NhbnZhcy1iYWNrZ3JvdW5kXCIsXG4gICAgeDogXCIwXCIsXG4gICAgeTogXCIwXCIsXG4gICAgd2lkdGg6IFwiMTAwJVwiLFxuICAgIGhlaWdodDogXCIxMDAlXCIsXG4gICAgZmlsbDogYmFja2dyb3VuZEltYWdlID8gXCJ1cmwoI1wiICsgaWQgKyBcIl9fYmFja2dyb3VuZClcIiA6IGNhbnZhc0NvbG9yXG4gIH0pKSwgcGF0aEdyb3Vwcy5tYXAoZnVuY3Rpb24gKHBhdGhHcm91cCwgaSkge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7XG4gICAgICBpZDogaWQgKyBcIl9fc3Ryb2tlLWdyb3VwLVwiICsgaSxcbiAgICAgIGtleTogaWQgKyBcIl9fc3Ryb2tlLWdyb3VwLVwiICsgaSxcbiAgICAgIG1hc2s6IFwidXJsKCNcIiArIGlkICsgXCJfX2VyYXNlci1tYXNrLVwiICsgaSArIFwiKVwiXG4gICAgfSwgUmVhY3QuY3JlYXRlRWxlbWVudChQYXRocywge1xuICAgICAgaWQ6IGlkLFxuICAgICAgcGF0aHM6IHBhdGhHcm91cFxuICAgIH0pKTtcbiAgfSkpKTtcbn0pO1xuXG52YXIgUmVhY3RTa2V0Y2hDYW52YXMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICB2YXIgX3Byb3BzJGlkID0gcHJvcHMuaWQsXG4gICAgICBpZCA9IF9wcm9wcyRpZCA9PT0gdm9pZCAwID8gJ3JlYWN0LXNrZXRjaC1jYW52YXMnIDogX3Byb3BzJGlkLFxuICAgICAgX3Byb3BzJHdpZHRoID0gcHJvcHMud2lkdGgsXG4gICAgICB3aWR0aCA9IF9wcm9wcyR3aWR0aCA9PT0gdm9pZCAwID8gJzEwMCUnIDogX3Byb3BzJHdpZHRoLFxuICAgICAgX3Byb3BzJGhlaWdodCA9IHByb3BzLmhlaWdodCxcbiAgICAgIGhlaWdodCA9IF9wcm9wcyRoZWlnaHQgPT09IHZvaWQgMCA/ICcxMDAlJyA6IF9wcm9wcyRoZWlnaHQsXG4gICAgICBfcHJvcHMkY2xhc3NOYW1lID0gcHJvcHMuY2xhc3NOYW1lLFxuICAgICAgY2xhc3NOYW1lID0gX3Byb3BzJGNsYXNzTmFtZSA9PT0gdm9pZCAwID8gJycgOiBfcHJvcHMkY2xhc3NOYW1lLFxuICAgICAgX3Byb3BzJGNhbnZhc0NvbG9yID0gcHJvcHMuY2FudmFzQ29sb3IsXG4gICAgICBjYW52YXNDb2xvciA9IF9wcm9wcyRjYW52YXNDb2xvciA9PT0gdm9pZCAwID8gJ3doaXRlJyA6IF9wcm9wcyRjYW52YXNDb2xvcixcbiAgICAgIF9wcm9wcyRzdHJva2VDb2xvciA9IHByb3BzLnN0cm9rZUNvbG9yLFxuICAgICAgc3Ryb2tlQ29sb3IgPSBfcHJvcHMkc3Ryb2tlQ29sb3IgPT09IHZvaWQgMCA/ICdyZWQnIDogX3Byb3BzJHN0cm9rZUNvbG9yLFxuICAgICAgX3Byb3BzJGJhY2tncm91bmRJbWFnID0gcHJvcHMuYmFja2dyb3VuZEltYWdlLFxuICAgICAgYmFja2dyb3VuZEltYWdlID0gX3Byb3BzJGJhY2tncm91bmRJbWFnID09PSB2b2lkIDAgPyAnJyA6IF9wcm9wcyRiYWNrZ3JvdW5kSW1hZyxcbiAgICAgIF9wcm9wcyRleHBvcnRXaXRoQmFjayA9IHByb3BzLmV4cG9ydFdpdGhCYWNrZ3JvdW5kSW1hZ2UsXG4gICAgICBleHBvcnRXaXRoQmFja2dyb3VuZEltYWdlID0gX3Byb3BzJGV4cG9ydFdpdGhCYWNrID09PSB2b2lkIDAgPyBmYWxzZSA6IF9wcm9wcyRleHBvcnRXaXRoQmFjayxcbiAgICAgIF9wcm9wcyRwcmVzZXJ2ZUJhY2tnciA9IHByb3BzLnByZXNlcnZlQmFja2dyb3VuZEltYWdlQXNwZWN0UmF0aW8sXG4gICAgICBwcmVzZXJ2ZUJhY2tncm91bmRJbWFnZUFzcGVjdFJhdGlvID0gX3Byb3BzJHByZXNlcnZlQmFja2dyID09PSB2b2lkIDAgPyAnbm9uZScgOiBfcHJvcHMkcHJlc2VydmVCYWNrZ3IsXG4gICAgICBfcHJvcHMkc3Ryb2tlV2lkdGggPSBwcm9wcy5zdHJva2VXaWR0aCxcbiAgICAgIHN0cm9rZVdpZHRoID0gX3Byb3BzJHN0cm9rZVdpZHRoID09PSB2b2lkIDAgPyA0IDogX3Byb3BzJHN0cm9rZVdpZHRoLFxuICAgICAgX3Byb3BzJGVyYXNlcldpZHRoID0gcHJvcHMuZXJhc2VyV2lkdGgsXG4gICAgICBlcmFzZXJXaWR0aCA9IF9wcm9wcyRlcmFzZXJXaWR0aCA9PT0gdm9pZCAwID8gOCA6IF9wcm9wcyRlcmFzZXJXaWR0aCxcbiAgICAgIF9wcm9wcyRhbGxvd09ubHlQb2ludCA9IHByb3BzLmFsbG93T25seVBvaW50ZXJUeXBlLFxuICAgICAgYWxsb3dPbmx5UG9pbnRlclR5cGUgPSBfcHJvcHMkYWxsb3dPbmx5UG9pbnQgPT09IHZvaWQgMCA/ICdhbGwnIDogX3Byb3BzJGFsbG93T25seVBvaW50LFxuICAgICAgX3Byb3BzJHN0eWxlID0gcHJvcHMuc3R5bGUsXG4gICAgICBzdHlsZSA9IF9wcm9wcyRzdHlsZSA9PT0gdm9pZCAwID8ge1xuICAgIGJvcmRlcjogJzAuMDYyNXJlbSBzb2xpZCAjOWM5YzljJyxcbiAgICBib3JkZXJSYWRpdXM6ICcwLjI1cmVtJ1xuICB9IDogX3Byb3BzJHN0eWxlLFxuICAgICAgX3Byb3BzJHN2Z1N0eWxlID0gcHJvcHMuc3ZnU3R5bGUsXG4gICAgICBzdmdTdHlsZSA9IF9wcm9wcyRzdmdTdHlsZSA9PT0gdm9pZCAwID8ge30gOiBfcHJvcHMkc3ZnU3R5bGUsXG4gICAgICBfcHJvcHMkb25DaGFuZ2UgPSBwcm9wcy5vbkNoYW5nZSxcbiAgICAgIG9uQ2hhbmdlID0gX3Byb3BzJG9uQ2hhbmdlID09PSB2b2lkIDAgPyBmdW5jdGlvbiAoX3BhdGhzKSB7fSA6IF9wcm9wcyRvbkNoYW5nZSxcbiAgICAgIF9wcm9wcyRvblN0cm9rZSA9IHByb3BzLm9uU3Ryb2tlLFxuICAgICAgb25TdHJva2UgPSBfcHJvcHMkb25TdHJva2UgPT09IHZvaWQgMCA/IGZ1bmN0aW9uIChfcGF0aCwgX2lzRXJhc2VyKSB7fSA6IF9wcm9wcyRvblN0cm9rZSxcbiAgICAgIF9wcm9wcyR3aXRoVGltZXN0YW1wID0gcHJvcHMud2l0aFRpbWVzdGFtcCxcbiAgICAgIHdpdGhUaW1lc3RhbXAgPSBfcHJvcHMkd2l0aFRpbWVzdGFtcCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfcHJvcHMkd2l0aFRpbWVzdGFtcDtcbiAgdmFyIHN2Z0NhbnZhcyA9IFJlYWN0LmNyZWF0ZVJlZigpO1xuXG4gIHZhciBfUmVhY3QkdXNlU3RhdGUgPSBSZWFjdC51c2VTdGF0ZSh0cnVlKSxcbiAgICAgIGRyYXdNb2RlID0gX1JlYWN0JHVzZVN0YXRlWzBdLFxuICAgICAgc2V0RHJhd01vZGUgPSBfUmVhY3QkdXNlU3RhdGVbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTIgPSBSZWFjdC51c2VTdGF0ZShmYWxzZSksXG4gICAgICBpc0RyYXdpbmcgPSBfUmVhY3QkdXNlU3RhdGUyWzBdLFxuICAgICAgc2V0SXNEcmF3aW5nID0gX1JlYWN0JHVzZVN0YXRlMlsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlMyA9IFJlYWN0LnVzZVN0YXRlKFtdKSxcbiAgICAgIHJlc2V0U3RhY2sgPSBfUmVhY3QkdXNlU3RhdGUzWzBdLFxuICAgICAgc2V0UmVzZXRTdGFjayA9IF9SZWFjdCR1c2VTdGF0ZTNbMV07XG5cbiAgdmFyIF9SZWFjdCR1c2VTdGF0ZTQgPSBSZWFjdC51c2VTdGF0ZShbXSksXG4gICAgICB1bmRvU3RhY2sgPSBfUmVhY3QkdXNlU3RhdGU0WzBdLFxuICAgICAgc2V0VW5kb1N0YWNrID0gX1JlYWN0JHVzZVN0YXRlNFsxXTtcblxuICB2YXIgX1JlYWN0JHVzZVN0YXRlNSA9IFJlYWN0LnVzZVN0YXRlKFtdKSxcbiAgICAgIGN1cnJlbnRQYXRocyA9IF9SZWFjdCR1c2VTdGF0ZTVbMF0sXG4gICAgICBzZXRDdXJyZW50UGF0aHMgPSBfUmVhY3QkdXNlU3RhdGU1WzFdO1xuXG4gIHZhciBsaWZ0U3Ryb2tlVXAgPSBSZWFjdC51c2VDYWxsYmFjayhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9jdXJyZW50UGF0aHMkc2xpY2UkLCBfY3VycmVudFBhdGhzJHNsaWNlO1xuXG4gICAgdmFyIGxhc3RTdHJva2UgPSAoX2N1cnJlbnRQYXRocyRzbGljZSQgPSAoX2N1cnJlbnRQYXRocyRzbGljZSA9IGN1cnJlbnRQYXRocy5zbGljZSgtMSkpID09IG51bGwgPyB2b2lkIDAgOiBfY3VycmVudFBhdGhzJHNsaWNlWzBdKSAhPSBudWxsID8gX2N1cnJlbnRQYXRocyRzbGljZSQgOiBudWxsO1xuXG4gICAgaWYgKGxhc3RTdHJva2UgPT09IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybignTm8gc3Ryb2tlIGZvdW5kIScpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG9uU3Ryb2tlKGxhc3RTdHJva2UsICFsYXN0U3Ryb2tlLmRyYXdNb2RlKTtcbiAgfSwgW2lzRHJhd2luZ10pO1xuICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGxpZnRTdHJva2VVcCgpO1xuICB9LCBbaXNEcmF3aW5nXSk7XG4gIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgb25DaGFuZ2UoY3VycmVudFBhdGhzKTtcbiAgfSwgW2N1cnJlbnRQYXRoc10pO1xuICBSZWFjdC51c2VJbXBlcmF0aXZlSGFuZGxlKHJlZiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBlcmFzZU1vZGU6IGZ1bmN0aW9uIGVyYXNlTW9kZShlcmFzZSkge1xuICAgICAgICBzZXREcmF3TW9kZSghZXJhc2UpO1xuICAgICAgfSxcbiAgICAgIGNsZWFyQ2FudmFzOiBmdW5jdGlvbiBjbGVhckNhbnZhcygpIHtcbiAgICAgICAgc2V0UmVzZXRTdGFjayhbXS5jb25jYXQoY3VycmVudFBhdGhzKSk7XG4gICAgICAgIHNldEN1cnJlbnRQYXRocyhbXSk7XG4gICAgICB9LFxuICAgICAgdW5kbzogZnVuY3Rpb24gdW5kbygpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGEgbGFzdCByZXNldCB0aGVuXG4gICAgICAgIGlmIChyZXNldFN0YWNrLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIHNldEN1cnJlbnRQYXRocyhbXS5jb25jYXQocmVzZXRTdGFjaykpO1xuICAgICAgICAgIHNldFJlc2V0U3RhY2soW10pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldFVuZG9TdGFjayhmdW5jdGlvbiAodW5kb1N0YWNrKSB7XG4gICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdCh1bmRvU3RhY2ssIGN1cnJlbnRQYXRocy5zbGljZSgtMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0Q3VycmVudFBhdGhzKGZ1bmN0aW9uIChjdXJyZW50UGF0aHMpIHtcbiAgICAgICAgICByZXR1cm4gY3VycmVudFBhdGhzLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgcmVkbzogZnVuY3Rpb24gcmVkbygpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBSZWRvXG4gICAgICAgIGlmICh1bmRvU3RhY2subGVuZ3RoID09PSAwKSByZXR1cm47XG4gICAgICAgIHNldEN1cnJlbnRQYXRocyhmdW5jdGlvbiAoY3VycmVudFBhdGhzKSB7XG4gICAgICAgICAgcmV0dXJuIFtdLmNvbmNhdChjdXJyZW50UGF0aHMsIHVuZG9TdGFjay5zbGljZSgtMSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0VW5kb1N0YWNrKGZ1bmN0aW9uICh1bmRvU3RhY2spIHtcbiAgICAgICAgICByZXR1cm4gdW5kb1N0YWNrLnNsaWNlKDAsIC0xKTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuICAgICAgZXhwb3J0SW1hZ2U6IGZ1bmN0aW9uIGV4cG9ydEltYWdlKGltYWdlVHlwZSkge1xuICAgICAgICB2YXIgX3N2Z0NhbnZhcyRjdXJyZW50O1xuXG4gICAgICAgIHZhciBleHBvcnRJbWFnZSA9IChfc3ZnQ2FudmFzJGN1cnJlbnQgPSBzdmdDYW52YXMuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdmdDYW52YXMkY3VycmVudC5leHBvcnRJbWFnZTtcblxuICAgICAgICBpZiAoIWV4cG9ydEltYWdlKSB7XG4gICAgICAgICAgdGhyb3cgRXJyb3IoJ0V4cG9ydCBmdW5jdGlvbiBjYWxsZWQgYmVmb3JlIGNhbnZhcyBsb2FkZWQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZXhwb3J0SW1hZ2UoaW1hZ2VUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGV4cG9ydFN2ZzogZnVuY3Rpb24gZXhwb3J0U3ZnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgIHZhciBfc3ZnQ2FudmFzJGN1cnJlbnQyO1xuXG4gICAgICAgICAgdmFyIGV4cG9ydFN2ZyA9IChfc3ZnQ2FudmFzJGN1cnJlbnQyID0gc3ZnQ2FudmFzLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfc3ZnQ2FudmFzJGN1cnJlbnQyLmV4cG9ydFN2ZztcblxuICAgICAgICAgIGlmICghZXhwb3J0U3ZnKSB7XG4gICAgICAgICAgICByZWplY3QoRXJyb3IoJ0V4cG9ydCBmdW5jdGlvbiBjYWxsZWQgYmVmb3JlIGNhbnZhcyBsb2FkZWQnKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGV4cG9ydFN2ZygpLnRoZW4oZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBleHBvcnRQYXRoczogZnVuY3Rpb24gZXhwb3J0UGF0aHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc29sdmUoY3VycmVudFBhdGhzKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBsb2FkUGF0aHM6IGZ1bmN0aW9uIGxvYWRQYXRocyhwYXRocykge1xuICAgICAgICBzZXRDdXJyZW50UGF0aHMoZnVuY3Rpb24gKGN1cnJlbnRQYXRocykge1xuICAgICAgICAgIHJldHVybiBbXS5jb25jYXQoY3VycmVudFBhdGhzLCBwYXRocyk7XG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIGdldFNrZXRjaGluZ1RpbWU6IGZ1bmN0aW9uIGdldFNrZXRjaGluZ1RpbWUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaWYgKCF3aXRoVGltZXN0YW1wKSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiU2V0ICd3aXRoVGltZXN0YW1wJyBwcm9wIHRvIGdldCBza2V0Y2hpbmcgdGltZVwiKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBza2V0Y2hpbmdUaW1lID0gY3VycmVudFBhdGhzLnJlZHVjZShmdW5jdGlvbiAodG90YWxTa2V0Y2hpbmdUaW1lLCBwYXRoKSB7XG4gICAgICAgICAgICAgIHZhciBfcGF0aCRzdGFydFRpbWVzdGFtcCwgX3BhdGgkZW5kVGltZXN0YW1wO1xuXG4gICAgICAgICAgICAgIHZhciBzdGFydFRpbWVzdGFtcCA9IChfcGF0aCRzdGFydFRpbWVzdGFtcCA9IHBhdGguc3RhcnRUaW1lc3RhbXApICE9IG51bGwgPyBfcGF0aCRzdGFydFRpbWVzdGFtcCA6IDA7XG4gICAgICAgICAgICAgIHZhciBlbmRUaW1lc3RhbXAgPSAoX3BhdGgkZW5kVGltZXN0YW1wID0gcGF0aC5lbmRUaW1lc3RhbXApICE9IG51bGwgPyBfcGF0aCRlbmRUaW1lc3RhbXAgOiAwO1xuICAgICAgICAgICAgICByZXR1cm4gdG90YWxTa2V0Y2hpbmdUaW1lICsgKGVuZFRpbWVzdGFtcCAtIHN0YXJ0VGltZXN0YW1wKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmVzb2x2ZShza2V0Y2hpbmdUaW1lKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICByZXNldENhbnZhczogZnVuY3Rpb24gcmVzZXRDYW52YXMoKSB7XG4gICAgICAgIHNldFJlc2V0U3RhY2soW10pO1xuICAgICAgICBzZXRVbmRvU3RhY2soW10pO1xuICAgICAgICBzZXRDdXJyZW50UGF0aHMoW10pO1xuICAgICAgfVxuICAgIH07XG4gIH0pO1xuXG4gIHZhciBoYW5kbGVQb2ludGVyRG93biA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJEb3duKHBvaW50KSB7XG4gICAgc2V0SXNEcmF3aW5nKHRydWUpO1xuICAgIHNldFVuZG9TdGFjayhbXSk7XG4gICAgdmFyIHN0cm9rZSA9IHtcbiAgICAgIGRyYXdNb2RlOiBkcmF3TW9kZSxcbiAgICAgIHN0cm9rZUNvbG9yOiBkcmF3TW9kZSA/IHN0cm9rZUNvbG9yIDogJyMwMDAwMDAnLFxuICAgICAgc3Ryb2tlV2lkdGg6IGRyYXdNb2RlID8gc3Ryb2tlV2lkdGggOiBlcmFzZXJXaWR0aCxcbiAgICAgIHBhdGhzOiBbcG9pbnRdXG4gICAgfTtcblxuICAgIGlmICh3aXRoVGltZXN0YW1wKSB7XG4gICAgICBzdHJva2UgPSBfZXh0ZW5kcyh7fSwgc3Ryb2tlLCB7XG4gICAgICAgIHN0YXJ0VGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBlbmRUaW1lc3RhbXA6IDBcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRQYXRocyhmdW5jdGlvbiAoY3VycmVudFBhdGhzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KGN1cnJlbnRQYXRocywgW3N0cm9rZV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb2ludGVyTW92ZSA9IGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlKHBvaW50KSB7XG4gICAgaWYgKCFpc0RyYXdpbmcpIHJldHVybjtcbiAgICB2YXIgY3VycmVudFN0cm9rZSA9IGN1cnJlbnRQYXRocy5zbGljZSgtMSlbMF07XG5cbiAgICB2YXIgdXBkYXRlZFN0cm9rZSA9IF9leHRlbmRzKHt9LCBjdXJyZW50U3Ryb2tlLCB7XG4gICAgICBwYXRoczogW10uY29uY2F0KGN1cnJlbnRTdHJva2UucGF0aHMsIFtwb2ludF0pXG4gICAgfSk7XG5cbiAgICBzZXRDdXJyZW50UGF0aHMoZnVuY3Rpb24gKGN1cnJlbnRQYXRocykge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdChjdXJyZW50UGF0aHMuc2xpY2UoMCwgLTEpLCBbdXBkYXRlZFN0cm9rZV0pO1xuICAgIH0pO1xuICB9O1xuXG4gIHZhciBoYW5kbGVQb2ludGVyVXAgPSBmdW5jdGlvbiBoYW5kbGVQb2ludGVyVXAoKSB7XG4gICAgdmFyIF9jdXJyZW50UGF0aHMkc2xpY2UkMiwgX2N1cnJlbnRQYXRocyRzbGljZTI7XG5cbiAgICBpZiAoIWlzRHJhd2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHNldElzRHJhd2luZyhmYWxzZSk7XG5cbiAgICBpZiAoIXdpdGhUaW1lc3RhbXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudFN0cm9rZSA9IChfY3VycmVudFBhdGhzJHNsaWNlJDIgPSAoX2N1cnJlbnRQYXRocyRzbGljZTIgPSBjdXJyZW50UGF0aHMuc2xpY2UoLTEpKSA9PSBudWxsID8gdm9pZCAwIDogX2N1cnJlbnRQYXRocyRzbGljZTJbMF0pICE9IG51bGwgPyBfY3VycmVudFBhdGhzJHNsaWNlJDIgOiBudWxsO1xuXG4gICAgaWYgKGN1cnJlbnRTdHJva2UgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlZFN0cm9rZSA9IF9leHRlbmRzKHt9LCBjdXJyZW50U3Ryb2tlLCB7XG4gICAgICBlbmRUaW1lc3RhbXA6IERhdGUubm93KClcbiAgICB9KTtcblxuICAgIHNldEN1cnJlbnRQYXRocyhmdW5jdGlvbiAoY3VycmVudFBhdGhzKSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KGN1cnJlbnRQYXRocy5zbGljZSgwLCAtMSksIFt1cGRhdGVkU3Ryb2tlXSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FudmFzLCB7XG4gICAgcmVmOiBzdmdDYW52YXMsXG4gICAgaWQ6IGlkLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICBjbGFzc05hbWU6IGNsYXNzTmFtZSxcbiAgICBjYW52YXNDb2xvcjogY2FudmFzQ29sb3IsXG4gICAgYmFja2dyb3VuZEltYWdlOiBiYWNrZ3JvdW5kSW1hZ2UsXG4gICAgZXhwb3J0V2l0aEJhY2tncm91bmRJbWFnZTogZXhwb3J0V2l0aEJhY2tncm91bmRJbWFnZSxcbiAgICBwcmVzZXJ2ZUJhY2tncm91bmRJbWFnZUFzcGVjdFJhdGlvOiBwcmVzZXJ2ZUJhY2tncm91bmRJbWFnZUFzcGVjdFJhdGlvLFxuICAgIGFsbG93T25seVBvaW50ZXJUeXBlOiBhbGxvd09ubHlQb2ludGVyVHlwZSxcbiAgICBzdHlsZTogc3R5bGUsXG4gICAgc3ZnU3R5bGU6IHN2Z1N0eWxlLFxuICAgIHBhdGhzOiBjdXJyZW50UGF0aHMsXG4gICAgaXNEcmF3aW5nOiBpc0RyYXdpbmcsXG4gICAgb25Qb2ludGVyRG93bjogaGFuZGxlUG9pbnRlckRvd24sXG4gICAgb25Qb2ludGVyTW92ZTogaGFuZGxlUG9pbnRlck1vdmUsXG4gICAgb25Qb2ludGVyVXA6IGhhbmRsZVBvaW50ZXJVcFxuICB9KTtcbn0pO1xuXG5leHBvcnQgeyBDYW52YXMsIFJlYWN0U2tldGNoQ2FudmFzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWFjdC1za2V0Y2gtY2FudmFzLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-sketch-canvas/dist/react-sketch-canvas.esm.js\n");

/***/ })

};
;